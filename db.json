{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/assets/img/phprbac_result.png","path":"assets/img/phprbac_result.png","modified":0,"renderable":0},{"_id":"source/assets/img/phprbac_table.png","path":"assets/img/phprbac_table.png","modified":0,"renderable":0},{"_id":"source/assets/img/vue_transition.png","path":"assets/img/vue_transition.png","modified":0,"renderable":0},{"_id":"source/assets/img/phprbac_tree_em.png","path":"assets/img/phprbac_tree_em.png","modified":0,"renderable":0},{"_id":"source/assets/img/rbac_intro.png","path":"assets/img/rbac_intro.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/user.jpg","path":"img/user.jpg","modified":0,"renderable":1},{"_id":"source/assets/img/phprbac_tree.png","path":"assets/img/phprbac_tree.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/assets/img/rbac_table.png","path":"assets/img/rbac_table.png","modified":0,"renderable":0},{"_id":"source/assets/img/instagrame.png","path":"assets/img/instagrame.png","modified":0,"renderable":0},{"_id":"source/assets/img/node_demultiplexer.png","path":"assets/img/node_demultiplexer.png","modified":1,"renderable":0},{"_id":"source/assets/img/node_architecture.png","path":"assets/img/node_architecture.png","modified":1,"renderable":0},{"_id":"source/assets/img/event_loop.png","path":"assets/img/event_loop.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia/.gitignore","hash":"0d5c2fdbdc974f10150baa12e1fc171a34960ed8","modified":1523950194963},{"_id":"source/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1523950194912},{"_id":"themes/yilia/README.md","hash":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1523950194963},{"_id":"themes/yilia/_config.yml","hash":"11adfdacd8e51dd8d5fe9e58cb1d779cac56fcca","modified":1523950194963},{"_id":"themes/yilia/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1523950194968},{"_id":"source/_posts/Node-js-设计模式读书笔记-第一章.md","hash":"8533644d1d5ede755662ecd244cad32dde8e3c6a","modified":1526628986068},{"_id":"source/_posts/VSCode配置.md","hash":"a772deb8cee76382310b9c425362f52851e50566","modified":1525611042796},{"_id":"source/_posts/Python-处理excel文件.md","hash":"bd42abc8d4a3070c1464df51ea03d9c8a3ace608","modified":1525942905774},{"_id":"source/_posts/Vue-过渡-动画.md","hash":"0a6f28e2f8454707e639e84e865fd3146f6f293b","modified":1526387871740},{"_id":"source/_posts/Vue基础的一些注意事项.md","hash":"dab6c5e430813a4283967519cd9cdd1861ca747e","modified":1525610975543},{"_id":"source/_posts/instagrame.md","hash":"4e31368f5dd6abc6d7029ef7d9551480ba4e9d12","modified":1523950194903},{"_id":"source/_posts/rbac-php.md","hash":"0f4a43fcb725204862ee17c53106205e6393c0c3","modified":1523954714000},{"_id":"source/categories/index.md","hash":"d221b12657f83398b03062066963add2b0db060c","modified":1523950194912},{"_id":"source/instagram/index.ejs","hash":"91ebb9fa670cc864dc03c91c46fd9bc44e769ed0","modified":1523950194913},{"_id":"source/instagram/index.md","hash":"4ca5b6c39da63f7b6b4f9b96ed7abbae579e69da","modified":1523950194913},{"_id":"source/tags/index.md","hash":"a7d47a97c714d064b40a73fd2a1efe2cb21bfe37","modified":1523950194913},{"_id":"themes/yilia/languages/de.yml","hash":"bc80f78f61c3d7af9652e6aa6fc3e4ff39b0c8d3","modified":1523950194964},{"_id":"themes/yilia/languages/en.yml","hash":"a093e794aef63ec9e9e9ef490cf7e4474e45e59f","modified":1523950194964},{"_id":"themes/yilia/languages/fr-FR.yml","hash":"04b9a0d80d88d01e039e8077afe88f741e9620ba","modified":1523950194964},{"_id":"themes/yilia/languages/default.yml","hash":"f0a7a032b31555c9ec05a711e1ac19bb07724708","modified":1523950194964},{"_id":"themes/yilia/languages/zh-Hans.yml","hash":"d2336578e14bb880d152266981c2b17523fc8742","modified":1523950194964},{"_id":"themes/yilia/languages/ru.yml","hash":"62f84ea82a696060c481fc22d4742e6201bb9bdc","modified":1523950194964},{"_id":"themes/yilia/languages/zh-hk.yml","hash":"e702fc43556e54c396917bdf7c869d528742e28b","modified":1523950194965},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"005559baa96b7bb34e1efe6b031829a95d58d5e0","modified":1523950194965},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1523950194967},{"_id":"themes/yilia/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1523950194968},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1523950194968},{"_id":"themes/yilia/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1523950194968},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1523950194968},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1523950194968},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1523950194968},{"_id":"source/assets/img/phprbac_result.png","hash":"3e7e822780948686fa871e4ce1de353efb21c439","modified":1523950194908},{"_id":"source/assets/img/phprbac_table.png","hash":"d1ebc14aa36366010931af18b98eca8593c560ab","modified":1523950194908},{"_id":"source/assets/img/vue_transition.png","hash":"918faae8f4e8e8d0b02c7516ba3c9931b9161487","modified":1525964097550},{"_id":"source/assets/img/phprbac_tree_em.png","hash":"18de30ff70ea4dd911e34a941100d2b9bceba6b3","modified":1523950194910},{"_id":"source/assets/img/rbac_intro.png","hash":"55a2fe0becd5c1052df73cf1cea1c4a82b022f1a","modified":1523950194910},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1523950194965},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"3709af4e8f7e1196dbd1f9dea62fa440d4b47836","modified":1523950194965},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"5b29a383418cfdcf8d5c5719b4fc4608aaba6fe7","modified":1523950194965},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"420b94c78832456686ebd9831a5bfcb05365645a","modified":1523950194965},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"2bbf5aad03f54055d9d7852e70ff7e6952a41f26","modified":1523950194966},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1523950194965},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1523950194966},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1523950194965},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"7be03a92dabeb2f94bf0e731d12a1c1146d736dd","modified":1523950194966},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"6a7a2a4960dabf9d7cd523573da7869eebf4b02d","modified":1523950194966},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"b03e8424b4798d4887801afdfae457fbf6027838","modified":1523950194966},{"_id":"themes/yilia/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1523950194969},{"_id":"themes/yilia/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1523950194971},{"_id":"themes/yilia/source/css/style.styl","hash":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1523950194973},{"_id":"themes/yilia/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1523950194974},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1523950194974},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1523950194974},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1523950194974},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1523950194974},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","hash":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1523950194975},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1523950194974},{"_id":"themes/yilia/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1523950194976},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1523950194976},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","hash":"004bb0812414554ab48067792f09e978603253b6","modified":1523950194976},{"_id":"themes/yilia/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1523950194976},{"_id":"themes/yilia/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1523950194977},{"_id":"themes/yilia/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1523950194977},{"_id":"themes/yilia/source/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1523950194977},{"_id":"themes/yilia/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1523950194977},{"_id":"themes/yilia/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1523950194977},{"_id":"themes/yilia/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1523950194977},{"_id":"themes/yilia/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1523950194977},{"_id":"themes/yilia/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1523950194978},{"_id":"themes/yilia/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1523950194978},{"_id":"themes/yilia/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1523950194978},{"_id":"themes/yilia/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1523950194978},{"_id":"themes/yilia/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1523950194978},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1523950194978},{"_id":"themes/yilia/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1523950194979},{"_id":"themes/yilia/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1523950194978},{"_id":"themes/yilia/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1523950194980},{"_id":"themes/yilia/source/js/instagram.js","hash":"2fc3d52bb2ab4d450d300c5c2675ba6ac1cb47c2","modified":1524148638000},{"_id":"themes/yilia/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1523950194980},{"_id":"themes/yilia/source/js/jquery.lazyload.js","hash":"9c34c37b4dca82386648d364da913153d1db902e","modified":1523950194980},{"_id":"themes/yilia/source/js/main.js","hash":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1523950194980},{"_id":"themes/yilia/source/js/mobile.js","hash":"387c047e661f04fbb5f5bfc4b2db617023e836ce","modified":1523950194980},{"_id":"themes/yilia/source/js/pc.js","hash":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1523950194981},{"_id":"themes/yilia/source/img/user.jpg","hash":"61c7bab73329e39084829ad4e72a1b7bcbaab1ca","modified":1523950194979},{"_id":"source/assets/img/phprbac_tree.png","hash":"ead7afd67568431953a1612d437255f1f46cdc97","modified":1523950194909},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"27fab3e6ccc41c075dc4c5ba3ca9e7f3b6247945","modified":1523950194966},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"06d8914b5aef73b5ec2cabb0105e275ff821b321","modified":1523950194966},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1523950194967},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"c115c282eebfb6b18612d2d8733272c270b03066","modified":1523950194967},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1523950194967},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","hash":"4ab6cab2a975a4df8419448b33dec4724279d85c","modified":1523950194967},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","hash":"d50294bf9858e7942208c380e851a37ed37f1d6f","modified":1523950194967},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"acf1b9d79ccec172881f9f0080e96667f4178885","modified":1523950194967},{"_id":"themes/yilia/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1523950194969},{"_id":"themes/yilia/source/css/_partial/archive.styl","hash":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1523950194969},{"_id":"themes/yilia/source/css/_partial/footer.styl","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1523950194969},{"_id":"themes/yilia/source/css/_partial/article.styl","hash":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1523950194969},{"_id":"themes/yilia/source/css/_partial/instagram.styl","hash":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1523950194970},{"_id":"themes/yilia/source/css/_partial/highlight.styl","hash":"08d3205dde3235f3e6881126268e6c473f46a8ac","modified":1523950194969},{"_id":"themes/yilia/source/css/_partial/main.styl","hash":"c368f1533053d4cffdf0ad982603271400b08e33","modified":1523950194970},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","hash":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1523950194970},{"_id":"themes/yilia/source/css/_partial/mobile.styl","hash":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1523950194970},{"_id":"themes/yilia/source/css/_partial/page.styl","hash":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1523950194970},{"_id":"themes/yilia/source/css/_partial/share.styl","hash":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1523950194971},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1523950194971},{"_id":"themes/yilia/source/css/_partial/scroll.styl","hash":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1523950194970},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","hash":"af0115de5c6455f899a2e09225b50224982c039d","modified":1523950194971},{"_id":"themes/yilia/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1523950194971},{"_id":"themes/yilia/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1523950194971},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1523950194972},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1523950194972},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1523950194973},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1523950194973},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1523950194975},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1523950194975},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1523950194975},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1523950194975},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1523950194975},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1523950194975},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1523950194972},{"_id":"source/assets/img/rbac_table.png","hash":"2ee989f7c456efc9ec795cb1f8c862cc44b9210c","modified":1523950194912},{"_id":"source/assets/img/instagrame.png","hash":"fb4e4f2a51bb3b1f9c316931bc20df0c78fd51a3","modified":1523950194907},{"_id":"source/.DS_Store","hash":"3f3f34c18fc5014adb844d86ecd773581956da40","modified":1526559850335},{"_id":"source/assets/.DS_Store","hash":"3eb5c9914e05b031b9e8ccedac83ecbb0359f7ba","modified":1526560082318},{"_id":"source/assets/img/node_demultiplexer.png","hash":"421fdae93ddb65b7ca0994d739f6ccf636f2e171","modified":1526560081289},{"_id":"source/assets/img/node_architecture.png","hash":"b222ad1f839b015ca6bf89d5c52edbb86c53e96b","modified":1526628767744},{"_id":"source/assets/img/event_loop.png","hash":"edb696ade8fc49e1a177f63a99c5502ed356a37d","modified":1526560625022}],"Category":[{"name":"生活","_id":"cjh692bx2000dmzfy5lzigsyd"}],"Data":[],"Page":[{"title":"categories","date":"2016-05-19T15:32:59.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-05-19 23:32:59\n---\n","updated":"2018-04-17T07:29:54.912Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjh692bwm0001mzfyfe9z9kfk","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","slug":"instagram","title":"相册","noDate":"true","_content":"\n<div class=\"instagram\" data-client-id=\"5c9e4068f0c8461bab7b23809c1cd923\" data-user-id=\"3252885684\">\n    <a href=\"https://www.instagram.com/hongchuanwang5879\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a>\n</div>\n<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-latest.js\"></script>\n<script src=\"/js/jquery.lazyload.js\"></script>\n<script src=\"/js/instagram.js\"></script>","source":"instagram/index.ejs","raw":"---\nlayout: post\nslug: \"instagram\"\ntitle: \"相册\"\nnoDate: \"true\"\n---\n\n<div class=\"instagram\" data-client-id=\"5c9e4068f0c8461bab7b23809c1cd923\" data-user-id=\"3252885684\">\n    <a href=\"https://www.instagram.com/hongchuanwang5879\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a>\n</div>\n<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-latest.js\"></script>\n<script src=\"/js/jquery.lazyload.js\"></script>\n<script src=\"/js/instagram.js\"></script>","date":"2018-04-17T07:29:54.913Z","updated":"2018-04-17T07:29:54.913Z","path":"instagram/index.html","comments":1,"_id":"cjh692bwp0003mzfy66a3tilo","content":"\n<div class=\"instagram\" data-client-id=\"5c9e4068f0c8461bab7b23809c1cd923\" data-user-id=\"3252885684\">\n    <a href=\"https://www.instagram.com/hongchuanwang5879\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a>\n</div>\n<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-latest.js\"></script>\n<script src=\"/js/jquery.lazyload.js\"></script>\n<script src=\"/js/instagram.js\"></script>","site":{"data":{}},"excerpt":"","more":"\n<div class=\"instagram\" data-client-id=\"5c9e4068f0c8461bab7b23809c1cd923\" data-user-id=\"3252885684\">\n    <a href=\"https://www.instagram.com/hongchuanwang5879\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a>\n</div>\n<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-latest.js\"></script>\n<script src=\"/js/jquery.lazyload.js\"></script>\n<script src=\"/js/instagram.js\"></script>"},{"layout":"post","slug":"instagram","title":"相册","noDate":"true","_content":"\n<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-latest.js\"></script>\n<script src=\"/js/jquery.lazyload.js\"></script>\n<script src=\"/js/instagram.js\"></script>\n<div class=\"instagram\" data-client-id=\"5c9e4068f0c8461bab7b23809c1cd923\" data-user-id=\"3252885684\">\n    <a href=\"https://www.instagram.com/hongchuanwang5879\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a>\n</div>\n","source":"instagram/index.md","raw":"---\nlayout: post\nslug: \"instagram\"\ntitle: \"相册\"\nnoDate: \"true\"\n---\n\n<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-latest.js\"></script>\n<script src=\"/js/jquery.lazyload.js\"></script>\n<script src=\"/js/instagram.js\"></script>\n<div class=\"instagram\" data-client-id=\"5c9e4068f0c8461bab7b23809c1cd923\" data-user-id=\"3252885684\">\n    <a href=\"https://www.instagram.com/hongchuanwang5879\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a>\n</div>\n","date":"2018-04-17T07:29:54.913Z","updated":"2018-04-17T07:29:54.913Z","path":"instagram/index.html","comments":1,"_id":"cjh692bxn000rmzfy518y8931","content":"<p><script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-latest.js\"></script></p>\n<p><script src=\"/js/jquery.lazyload.js\"></script></p>\n<p><script src=\"/js/instagram.js\"></script></p>\n<div class=\"instagram\" data-client-id=\"5c9e4068f0c8461bab7b23809c1cd923\" data-user-id=\"3252885684\"><br>    <a href=\"https://www.instagram.com/hongchuanwang5879\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a><br></div>\n","site":{"data":{}},"excerpt":"","more":"<p><script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-latest.js\"></script></p>\n<p><script src=\"/js/jquery.lazyload.js\"></script></p>\n<p><script src=\"/js/instagram.js\"></script></p>\n<div class=\"instagram\" data-client-id=\"5c9e4068f0c8461bab7b23809c1cd923\" data-user-id=\"3252885684\"><br>    <a href=\"https://www.instagram.com/hongchuanwang5879\" target=\"_blank\" class=\"open-ins\">图片来自instagram，正在加载中…</a><br></div>\n"},{"title":"tags","date":"2016-05-19T15:32:11.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-05-19 23:32:11\n---\n","updated":"2018-04-17T07:29:54.913Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjh692bxp000smzfy6wsdnl7e","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"《Node.js 设计模式》读书笔记 第一章","date":"2018-05-11T12:00:45.000Z","_content":"\n# Welcome to the Node.js Platform\n\n## Small modules(小模块)\n\n`Node.js`使用`module`(模块)的概念组织代码的结构。  \n\b`package`可提供复用的模块，有一个 module 作为入口。  \n`Node.js`中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：\n\n<!-- more -->\n\n> * \"Small is beautiful.\"(小而精)\n> * \"Make each program do one thing well.\" (每个程序只有单一的职责)\n\n`Node.js` 通过官方包管理工具`npm`解决包之间的依赖问题，每个`package\b`都有它自己的依赖，故而一个程序中多个`package`能够无冲突地安装。应用程序都是由一个个很小的、单职责的依赖构成的。\n\n**小模块**应该有的特性：\n\n> * Easier to understand and use(易理解、易用)\n> * Simpler to test and maintain(易于测试和维护)\n> * Perfect to share with the browser(完美支持浏览器)\n\n**DRY(Dont't Repeat Yourself)原则**\n\n## Small surface area(暴露需要的接口)\n\n一般使用者只会用到很有限的功能，而很少去 \b 扩展一个模块，所以`Node.js`的很多模块只会暴露一个函数或者一个构造器，然后把更细节的东西都放在函数或者构造器里，这样能帮助 \b 使用者认清什么是主要的什么是次要的.\n\n模块是不允许被扩展的，看起来扩展性低，但实际上有很多优势：减少了应用场景(这样考虑的情况就少了，容易实现)，简化了实现，便于维护，提高了可用性。\n\n## Simplicity and progmatism(简单而实用)\n\n> 简单就是复杂到极致。—— 达尔文\n\n> 设计必须简单，\b 不管是实现还是接口。实现的简洁比接口的简洁更重要。设计中最重要的就是简洁。—— Richard P.Gabriel(一位杰出的计算机科学家)\n\n设计简单的而不是完美或功能完备的软件是一个好的实践：\n\n* \b 更容易实现\n* 更少的资源，传输更快\n* 更容易适应\n* 容易维护和理解\n\n设计简单这个原则同样也适用于`JavaScript`，简单函数、闭包、`object`替代了复杂的类继承。\n\n## Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)\n\n### The let and const keywords(let 和 const 关键字)\n\n在之前(ES2015 之前)，`js`只支持函数作用域和全局作用域，例如在 if 中声明一个变量却能在 if 块之外访问：\n\n```js\nif (false) {\n  var x = 'hello'\n}\n\nconsole.log(x) //undefined\n```\n\n但是使用`let`关键字后，if 块外就访问不到其中声明的变量了，这在一定程度上能减少因为误操作其中的变量而导致的 bug：\n\n```js\nif (false) {\n  let x = 'hello'\n}\n\nconsole.log(x) //ReferenceError: x is not defined\n```\n\n`const`关键字用于声明不可变变量：\n\n```js\nconst x = 'This will never change'\nx = '...'\n//TypeError: Assignment to constant variable\n```\n\n需要注意的是，\b`const` \b 是意味着变量的绑定不变而不是内容不变，示例入下：\n\n```js\ncosnt x = {}\nx.name = 'John'//work\n\nx = null//don't work\n```\n\n通常来说引入模块使用 \b`const`防止模块发生变化：\n\n```js\nconst path = require('path')\n\nlet path = './some/path' //fail\n```\n\n如果你想要创建一个不可更改的对象，`const`是不够的，你可以使用 ES5 的[Object.freeze()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)或者 \b[deep-freeze](https://www.npmjs.com/package/deep-freeze)模块，或者我使用`react`框架时候经常用的[immutable](https://www.npmjs.com/package/immutable)模块也可以。\n\n> 扩展——这里提一下**ES5**中`freeze`和`seal`的区别，`seal`只限制无法增加和删除对象属性 \b，而`freeze`在`seal`的基础上还限制了不可更改对象的属性。\n\n### The arrow function(箭头函数)\n\n箭头函数是**ES6**的一大亮点，能很大程度上简化代码。一个参数可以不需要圆括号，函数体只有一行且结果为返回值可不需要花括号，具体示例如下：\n\n```js\nconst numbers = [2, 6, 7, 8, 1]\nconst event = numbers.filter(x => x % 2 === 0)\n\nconst event2 = numbers.filter(x => {\n  if (x % 2 === 0) {\n    return true\n  }\n})\n```\n\n箭头函数中 this 的指向跟随父函数，示例：\n\n```js\nfunction DelayedGreeter(name) {\n  this.name = name\n}\n\nDelayedGreeter.prototype.greet = function() {\n  setTimeout(function cb() {\n    console.log('Hello ' + this.name)\n  })\n}\n\nnew DelayedGreeter('World').greet() //Hello undefined\n\nDelayedGreeter.prototype.greet = function() {\n  setTimeout(() => console.log('Hello ' + this.name))\n}\n\nnew DelayedGreeter('World').greet() //Hello World\n```\n\n### Class syntax(Class 语法)\n\n`class`只是个语法糖，使用 class 实现对象继承并不是通过`class`继承的，还是通过内部的 prototypes，properties 实现继承，但是`class`使得程序可读性变强了。\n\n让我们来看个例子：\n\n```js\n//复杂，晦涩难懂\nfunction Person(name, surname, age) {\n  this.name = name\n  this.surname = surname\n  this.age = age\n}\n\nPerson.prototype.getFullName = function() {\n  return this.name + ' ' + this.surname\n}\n\nPerson.older = function(person1, person2) {\n  return preson1.age >= person2.age ? person1 : person2\n}\n\n//易懂\nclass Person {\n  constructor(name, surname, age) {\n    this.name = name\n    this.surname = surname\n    this.age = age\n  }\n\n  getFullName() {\n    return this.name + ' ' + this.surname\n  }\n\n  static older(person1, person2) {\n    return preson1.age >= person2.age ? person1 : person2\n  }\n}\n\nclass PersonWithMiddlename extends Person {\n  constructor(name, middlename, surname, age) {\n    super(name, surname, age)\n    this.middlename = middlename\n  }\n\n  getFullName() {\n    return this.name + ' ' + this.middlename + ' ' + this.surname\n  }\n}\n```\n\n### Enhanced object literals(对象字面量语法增强)\n\n* 缺省键值，属性名和变量名相同时可省略属性名\n\n```js\nconst x = 22\nconst y = 17\nconst obj = { x, y }\n```\n\n* 计算属性，属性可以是由变量计算而来\n\n```js\nconst namespace = '-webkit-'\nconst style = {\n  [namespace + 'box-sizing']: 'border-box',\n  [namespace + 'box-shadow']: '10px 10px 5px #888888'\n}\n```\n\n* getter 和 setter\n\n先看例子：\n\n```js\nconst person = {\n  name: 'George',\n  surname: 'Boole',\n  get fullname() {\n    return this.name + '' + this.surname\n  },\n  set fullname(fullname) {\n    let parts = fullname.split('')\n    this.name = parts[0]\n    this.surname = parts[1]\n  }\n}\nconsole.log(person.fullname) // \"George Boole\"\nconsole.log((person.fullname = 'Alan Turing')) // \"Alan Turing\"\nconsole.log(person.name) // \"Alan\"\n```\n\n可以看到第二个 console.log 输出的是“Alan Turing”，这是因为调用 set 后默认返回 get 获得的值。\n\n### Map and Set collections(Map 和 Set 集合)\n\n原来我们建立 hash map 的时候都是用`object`来完成的，而现在可以直接使用`Map`原型，提供了 set、get、has、delete 方法和 size 属性，比使用`object`更加直接、简单，遍历可使用`for...of`语法，这种遍历方式是和 Map 中属性的插入顺序是一样的(这在普通`object`中是无法保证的)。\n\n```js\nconst tests = new Map();\n   tests.set(() => 2+2, 4);\n   tests.set(() => 2*2, 4);\n   tests.set(() => 2/2, 1);\n   for (const entry of tests) {\n     console.log((entry[0]() === entry[1])   'PASS' : 'FAIL');\n}\n```\n\n`Set`只允许存在不同的值，和数学上的集合是一个概念，里面内容可以是`number`也可以是`object`或`function`，除了 set 换成 add 外其他的都与 map 相同，遍历时每一个 entry 内容是 value。\n\n### WeakMap and WeakSet collections\n\n顾名思义，`WeakMap`和`WeakSet`是`Map`和`Set`弱化后的原型，但是这其中并无优劣之分，只是适用于不同的场合。\n\n`WeakMap`的**key**只能是非空对象，对**key**仅保持弱引用，最大的好处是可以避免内存泄漏，一旦**key**的引用为空或者 undefined，垃圾回收器就可以回收这个对象，但是`WeakMap`不能迭代遍历。\n\n`WeakSet`与`WeakMap`同。\n\n### Template literals(模板字符串)\n\n使用`代替双引号和单引号，在字符串中可以使用表达式${expression}，可以换行。\n\n### ES6 其他语法\n\n* [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)(稍后会详细讲到)\n* [函数默认参数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters)\n* [剩余参数语法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Rest_parameters)\n* [拓展运算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator)\n* [解构赋值](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n* [new.target](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target)\n* [代理](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n* [反射](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect)\n* [Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol)\n\n## The reactor pattern\n\n`reactor`模式是 `Node.js` 异步的核心。\n\n### I/O is slow(I/O 操作是慢的)\n\nI/O 操作可以说是计算机操作中最慢的一环，I/O 的速度可能和网络速度、磁盘速率有关，也可能和其他因素有关，比如用户点击事件等等。\n\n### Blocking I/O(阻塞 I/O)\n\n传统的阻塞 I/O 模型中，I/O 请求会阻塞之后代码块的运行，例如：\n\n```js\n// 直到请求完成，数据可用，线程都是阻塞的\ndata = socket.read()\n// 请求完成，数据可用\nprint(data)\n```\n\n而为了达到并发的 \b 目的，传统的 web 服务器是 \b 选择新开一个线程或进程，这样因为线程(或进程)之间的相互独立性，一个线程(或进程)阻塞并不会影响另一个。\n\n但是创建一个线程是昂贵的，一个线程需要内存，而且切换线程需要保留线程的上下文等等，所以这种方式并不是最佳实践。\n\n### Non-blocking I/O(非阻塞 I/O)\n\n与阻塞 I/O 相反，遇到 I/O 请求不会阻塞后续代码的执行，如果访问的资源不可用则会返回一个预定义的常量值。\n\n非阻塞 I/O 最基本的模式是轮询直到有数据已经返回了，也叫做 \b`忙等待`模式：\n\n```js\nresources = [socketA, socketB, pipeA]\nwhile (!resources.isEmpty()) {\n  for (i = 0; i < resources.length; i++) {\n    resource = resources[i]\n    // 进行读操作\n    let data = resource.read()\n    if (data === NO_DATA_AVAILABLE) {\n      // 此时还没有数据\n      continue\n    }\n    if (data === RESOURCE_CLOSED) {\n      // 资源被释放，从队列中移除该链接\n      resources.remove(i)\n    } else {\n      consumeData(data)\n    }\n  }\n}\n```\n\n这个例子已经能有单线程处理多个请求了，\b 但是不够高效，资源不可用时循环占了太多了 CPU 时间，轮询算法 \b 浪费 CPU 时间。\n\n### Event demultiplexing(事件多路复用)\n\n对于获取非阻塞的资源而言，忙等待模型不是一个理想的技术，大多数现代的操作系统都提供了一种机制来处理并发和非阻塞资源，这个机制被称为`同步多路复用`。\n\n这个组件从一系列被监听的资源中收集 I/O 事件并放入队列中，而且会一直处于阻塞状态直到有新的事件可以被处理：\n\n```js\nsocketA, pipeB;\nwachedList.add(socketA, FOR_READ);\nwachedList.add(pipeB, FOR_READ);\nwhile(events = demultiplexer.watch(wachedList)) {\n  // 事件循环\n  foreach(event in events) {\n    // 永远不会阻塞，并且总会有返回值\n    data = event.resource.read();\n    if (data === RESOURCE_CLOSED) {\n      // 资源已经被释放，从观察者队列移除\n      demultiplexer.unwatch(event.resource);\n    } else {\n      // 获得数据进行处理\n      consumeData(data);\n    }\n  }\n}\n```\n\n代码的三个重要步骤：\n\n1.  资源被添加到一个数据结构中，为每个资源关联一个特定的操作，在这个例子中是 read。\n2.  事件通知器由一组被观察的资源组成，事件通知器是同步和阻塞的直到有资源可以被`read`，事件触发后会从调用中返回，之后这些事件可以被处理。\n3.  多路复用器返回的每个事件被处理，此时，和事件相关的资源都可用且不会在操作中阻塞。当所有的事件都被处理完后，继续进入循环等待下一个可以被处理的事件。这个被称作为`事件循环`。\n\n![多路复用](/assets/img/node_demultiplexer.png)\n\n上图帮助我们理解如何在一个单线程中使用多路复用器和非阻塞 I/O 来处理并发。我们能够看到，只使用一个线程并不会影响我们处理多个 I/O 任务的性能。同时，我们看到任务是在单个线程中随着时间的推移而展开的，而不是分散在多个线程中。我们看到，在单线程中传播的任务相对于多线程中传播的任务反而节约了线程的总体空闲时间，并且更利于程序员编写代码。\n\n### Introducing to reactor pattern(reactor 模式的介绍)\n\n主要思想就是每一个 I/O 操作都有一个`handler`或者成为回调函数(`callback`)，当事件发生并且被`事件循环`处理后，这个回调函数就会被调用：\n\n![event loop](/assets/img/event_loop.png)\n\n一个应用使用`reactor`模式后：\n\n1.  应用提交一个请求给事件多路复用器 \b，生成 I/O 操作，同时提供事件触发时的`handler`，\b 发送请求给事件多路复用器是一个非阻塞的操作，发送后立即返回到应用。\n2.  当一组 I/O 操作完成，事件多路复用器会将新来的事件添加到事件队列中。\n3.  此时，事件循环会迭代事件队列中的每个事件。\n4.  对于每个事件，对应的`handler`被处理。\n5.  `handler`，是应用程序代码的一部分，`handler`执行结束后执行权会交回事件循环。但是，在`handler`执行时可能请求新的异步操作，从而新的操作被添加到事件多路复用器。\n6.  当事件队列的全部事件被处理完后，事件多路复用器再次阻塞直到有一个新的事件触发。\n\n现在来定义 Node.js 的核心模式：  \n`\b模式(reactor)`这样处理 I/O，阻塞直到有新的事件从被观察的资源中触发，然后将事件派发给相应的`handler`。\n\n### Node.js 非阻塞 I/O 引擎——libuv\n\n每个操作系统都有不同的接口来实现事件多路复用器，Linux 是 epoll，Mac OSX 是 kqueue，Windows 的 IOCP API，即使是在相同的操作系统中对于不同资源的I/O操作也不同，所以Node.js使用`libuv`来统一处理I/O操作，来达到兼容不同操作系统的目的。\n\n### Node.js 架构\n\n![Node.js 架构](/assets/img/node_architecture.png)\n","source":"_posts/Node-js-设计模式读书笔记-第一章.md","raw":"---\ntitle: 《Node.js 设计模式》读书笔记 第一章\ndate: 2018-05-11 20:00:45\ntags:\n    - 读书笔记\n---\n\n# Welcome to the Node.js Platform\n\n## Small modules(小模块)\n\n`Node.js`使用`module`(模块)的概念组织代码的结构。  \n\b`package`可提供复用的模块，有一个 module 作为入口。  \n`Node.js`中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：\n\n<!-- more -->\n\n> * \"Small is beautiful.\"(小而精)\n> * \"Make each program do one thing well.\" (每个程序只有单一的职责)\n\n`Node.js` 通过官方包管理工具`npm`解决包之间的依赖问题，每个`package\b`都有它自己的依赖，故而一个程序中多个`package`能够无冲突地安装。应用程序都是由一个个很小的、单职责的依赖构成的。\n\n**小模块**应该有的特性：\n\n> * Easier to understand and use(易理解、易用)\n> * Simpler to test and maintain(易于测试和维护)\n> * Perfect to share with the browser(完美支持浏览器)\n\n**DRY(Dont't Repeat Yourself)原则**\n\n## Small surface area(暴露需要的接口)\n\n一般使用者只会用到很有限的功能，而很少去 \b 扩展一个模块，所以`Node.js`的很多模块只会暴露一个函数或者一个构造器，然后把更细节的东西都放在函数或者构造器里，这样能帮助 \b 使用者认清什么是主要的什么是次要的.\n\n模块是不允许被扩展的，看起来扩展性低，但实际上有很多优势：减少了应用场景(这样考虑的情况就少了，容易实现)，简化了实现，便于维护，提高了可用性。\n\n## Simplicity and progmatism(简单而实用)\n\n> 简单就是复杂到极致。—— 达尔文\n\n> 设计必须简单，\b 不管是实现还是接口。实现的简洁比接口的简洁更重要。设计中最重要的就是简洁。—— Richard P.Gabriel(一位杰出的计算机科学家)\n\n设计简单的而不是完美或功能完备的软件是一个好的实践：\n\n* \b 更容易实现\n* 更少的资源，传输更快\n* 更容易适应\n* 容易维护和理解\n\n设计简单这个原则同样也适用于`JavaScript`，简单函数、闭包、`object`替代了复杂的类继承。\n\n## Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)\n\n### The let and const keywords(let 和 const 关键字)\n\n在之前(ES2015 之前)，`js`只支持函数作用域和全局作用域，例如在 if 中声明一个变量却能在 if 块之外访问：\n\n```js\nif (false) {\n  var x = 'hello'\n}\n\nconsole.log(x) //undefined\n```\n\n但是使用`let`关键字后，if 块外就访问不到其中声明的变量了，这在一定程度上能减少因为误操作其中的变量而导致的 bug：\n\n```js\nif (false) {\n  let x = 'hello'\n}\n\nconsole.log(x) //ReferenceError: x is not defined\n```\n\n`const`关键字用于声明不可变变量：\n\n```js\nconst x = 'This will never change'\nx = '...'\n//TypeError: Assignment to constant variable\n```\n\n需要注意的是，\b`const` \b 是意味着变量的绑定不变而不是内容不变，示例入下：\n\n```js\ncosnt x = {}\nx.name = 'John'//work\n\nx = null//don't work\n```\n\n通常来说引入模块使用 \b`const`防止模块发生变化：\n\n```js\nconst path = require('path')\n\nlet path = './some/path' //fail\n```\n\n如果你想要创建一个不可更改的对象，`const`是不够的，你可以使用 ES5 的[Object.freeze()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)或者 \b[deep-freeze](https://www.npmjs.com/package/deep-freeze)模块，或者我使用`react`框架时候经常用的[immutable](https://www.npmjs.com/package/immutable)模块也可以。\n\n> 扩展——这里提一下**ES5**中`freeze`和`seal`的区别，`seal`只限制无法增加和删除对象属性 \b，而`freeze`在`seal`的基础上还限制了不可更改对象的属性。\n\n### The arrow function(箭头函数)\n\n箭头函数是**ES6**的一大亮点，能很大程度上简化代码。一个参数可以不需要圆括号，函数体只有一行且结果为返回值可不需要花括号，具体示例如下：\n\n```js\nconst numbers = [2, 6, 7, 8, 1]\nconst event = numbers.filter(x => x % 2 === 0)\n\nconst event2 = numbers.filter(x => {\n  if (x % 2 === 0) {\n    return true\n  }\n})\n```\n\n箭头函数中 this 的指向跟随父函数，示例：\n\n```js\nfunction DelayedGreeter(name) {\n  this.name = name\n}\n\nDelayedGreeter.prototype.greet = function() {\n  setTimeout(function cb() {\n    console.log('Hello ' + this.name)\n  })\n}\n\nnew DelayedGreeter('World').greet() //Hello undefined\n\nDelayedGreeter.prototype.greet = function() {\n  setTimeout(() => console.log('Hello ' + this.name))\n}\n\nnew DelayedGreeter('World').greet() //Hello World\n```\n\n### Class syntax(Class 语法)\n\n`class`只是个语法糖，使用 class 实现对象继承并不是通过`class`继承的，还是通过内部的 prototypes，properties 实现继承，但是`class`使得程序可读性变强了。\n\n让我们来看个例子：\n\n```js\n//复杂，晦涩难懂\nfunction Person(name, surname, age) {\n  this.name = name\n  this.surname = surname\n  this.age = age\n}\n\nPerson.prototype.getFullName = function() {\n  return this.name + ' ' + this.surname\n}\n\nPerson.older = function(person1, person2) {\n  return preson1.age >= person2.age ? person1 : person2\n}\n\n//易懂\nclass Person {\n  constructor(name, surname, age) {\n    this.name = name\n    this.surname = surname\n    this.age = age\n  }\n\n  getFullName() {\n    return this.name + ' ' + this.surname\n  }\n\n  static older(person1, person2) {\n    return preson1.age >= person2.age ? person1 : person2\n  }\n}\n\nclass PersonWithMiddlename extends Person {\n  constructor(name, middlename, surname, age) {\n    super(name, surname, age)\n    this.middlename = middlename\n  }\n\n  getFullName() {\n    return this.name + ' ' + this.middlename + ' ' + this.surname\n  }\n}\n```\n\n### Enhanced object literals(对象字面量语法增强)\n\n* 缺省键值，属性名和变量名相同时可省略属性名\n\n```js\nconst x = 22\nconst y = 17\nconst obj = { x, y }\n```\n\n* 计算属性，属性可以是由变量计算而来\n\n```js\nconst namespace = '-webkit-'\nconst style = {\n  [namespace + 'box-sizing']: 'border-box',\n  [namespace + 'box-shadow']: '10px 10px 5px #888888'\n}\n```\n\n* getter 和 setter\n\n先看例子：\n\n```js\nconst person = {\n  name: 'George',\n  surname: 'Boole',\n  get fullname() {\n    return this.name + '' + this.surname\n  },\n  set fullname(fullname) {\n    let parts = fullname.split('')\n    this.name = parts[0]\n    this.surname = parts[1]\n  }\n}\nconsole.log(person.fullname) // \"George Boole\"\nconsole.log((person.fullname = 'Alan Turing')) // \"Alan Turing\"\nconsole.log(person.name) // \"Alan\"\n```\n\n可以看到第二个 console.log 输出的是“Alan Turing”，这是因为调用 set 后默认返回 get 获得的值。\n\n### Map and Set collections(Map 和 Set 集合)\n\n原来我们建立 hash map 的时候都是用`object`来完成的，而现在可以直接使用`Map`原型，提供了 set、get、has、delete 方法和 size 属性，比使用`object`更加直接、简单，遍历可使用`for...of`语法，这种遍历方式是和 Map 中属性的插入顺序是一样的(这在普通`object`中是无法保证的)。\n\n```js\nconst tests = new Map();\n   tests.set(() => 2+2, 4);\n   tests.set(() => 2*2, 4);\n   tests.set(() => 2/2, 1);\n   for (const entry of tests) {\n     console.log((entry[0]() === entry[1])   'PASS' : 'FAIL');\n}\n```\n\n`Set`只允许存在不同的值，和数学上的集合是一个概念，里面内容可以是`number`也可以是`object`或`function`，除了 set 换成 add 外其他的都与 map 相同，遍历时每一个 entry 内容是 value。\n\n### WeakMap and WeakSet collections\n\n顾名思义，`WeakMap`和`WeakSet`是`Map`和`Set`弱化后的原型，但是这其中并无优劣之分，只是适用于不同的场合。\n\n`WeakMap`的**key**只能是非空对象，对**key**仅保持弱引用，最大的好处是可以避免内存泄漏，一旦**key**的引用为空或者 undefined，垃圾回收器就可以回收这个对象，但是`WeakMap`不能迭代遍历。\n\n`WeakSet`与`WeakMap`同。\n\n### Template literals(模板字符串)\n\n使用`代替双引号和单引号，在字符串中可以使用表达式${expression}，可以换行。\n\n### ES6 其他语法\n\n* [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)(稍后会详细讲到)\n* [函数默认参数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters)\n* [剩余参数语法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Rest_parameters)\n* [拓展运算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator)\n* [解构赋值](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n* [new.target](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target)\n* [代理](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n* [反射](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect)\n* [Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol)\n\n## The reactor pattern\n\n`reactor`模式是 `Node.js` 异步的核心。\n\n### I/O is slow(I/O 操作是慢的)\n\nI/O 操作可以说是计算机操作中最慢的一环，I/O 的速度可能和网络速度、磁盘速率有关，也可能和其他因素有关，比如用户点击事件等等。\n\n### Blocking I/O(阻塞 I/O)\n\n传统的阻塞 I/O 模型中，I/O 请求会阻塞之后代码块的运行，例如：\n\n```js\n// 直到请求完成，数据可用，线程都是阻塞的\ndata = socket.read()\n// 请求完成，数据可用\nprint(data)\n```\n\n而为了达到并发的 \b 目的，传统的 web 服务器是 \b 选择新开一个线程或进程，这样因为线程(或进程)之间的相互独立性，一个线程(或进程)阻塞并不会影响另一个。\n\n但是创建一个线程是昂贵的，一个线程需要内存，而且切换线程需要保留线程的上下文等等，所以这种方式并不是最佳实践。\n\n### Non-blocking I/O(非阻塞 I/O)\n\n与阻塞 I/O 相反，遇到 I/O 请求不会阻塞后续代码的执行，如果访问的资源不可用则会返回一个预定义的常量值。\n\n非阻塞 I/O 最基本的模式是轮询直到有数据已经返回了，也叫做 \b`忙等待`模式：\n\n```js\nresources = [socketA, socketB, pipeA]\nwhile (!resources.isEmpty()) {\n  for (i = 0; i < resources.length; i++) {\n    resource = resources[i]\n    // 进行读操作\n    let data = resource.read()\n    if (data === NO_DATA_AVAILABLE) {\n      // 此时还没有数据\n      continue\n    }\n    if (data === RESOURCE_CLOSED) {\n      // 资源被释放，从队列中移除该链接\n      resources.remove(i)\n    } else {\n      consumeData(data)\n    }\n  }\n}\n```\n\n这个例子已经能有单线程处理多个请求了，\b 但是不够高效，资源不可用时循环占了太多了 CPU 时间，轮询算法 \b 浪费 CPU 时间。\n\n### Event demultiplexing(事件多路复用)\n\n对于获取非阻塞的资源而言，忙等待模型不是一个理想的技术，大多数现代的操作系统都提供了一种机制来处理并发和非阻塞资源，这个机制被称为`同步多路复用`。\n\n这个组件从一系列被监听的资源中收集 I/O 事件并放入队列中，而且会一直处于阻塞状态直到有新的事件可以被处理：\n\n```js\nsocketA, pipeB;\nwachedList.add(socketA, FOR_READ);\nwachedList.add(pipeB, FOR_READ);\nwhile(events = demultiplexer.watch(wachedList)) {\n  // 事件循环\n  foreach(event in events) {\n    // 永远不会阻塞，并且总会有返回值\n    data = event.resource.read();\n    if (data === RESOURCE_CLOSED) {\n      // 资源已经被释放，从观察者队列移除\n      demultiplexer.unwatch(event.resource);\n    } else {\n      // 获得数据进行处理\n      consumeData(data);\n    }\n  }\n}\n```\n\n代码的三个重要步骤：\n\n1.  资源被添加到一个数据结构中，为每个资源关联一个特定的操作，在这个例子中是 read。\n2.  事件通知器由一组被观察的资源组成，事件通知器是同步和阻塞的直到有资源可以被`read`，事件触发后会从调用中返回，之后这些事件可以被处理。\n3.  多路复用器返回的每个事件被处理，此时，和事件相关的资源都可用且不会在操作中阻塞。当所有的事件都被处理完后，继续进入循环等待下一个可以被处理的事件。这个被称作为`事件循环`。\n\n![多路复用](/assets/img/node_demultiplexer.png)\n\n上图帮助我们理解如何在一个单线程中使用多路复用器和非阻塞 I/O 来处理并发。我们能够看到，只使用一个线程并不会影响我们处理多个 I/O 任务的性能。同时，我们看到任务是在单个线程中随着时间的推移而展开的，而不是分散在多个线程中。我们看到，在单线程中传播的任务相对于多线程中传播的任务反而节约了线程的总体空闲时间，并且更利于程序员编写代码。\n\n### Introducing to reactor pattern(reactor 模式的介绍)\n\n主要思想就是每一个 I/O 操作都有一个`handler`或者成为回调函数(`callback`)，当事件发生并且被`事件循环`处理后，这个回调函数就会被调用：\n\n![event loop](/assets/img/event_loop.png)\n\n一个应用使用`reactor`模式后：\n\n1.  应用提交一个请求给事件多路复用器 \b，生成 I/O 操作，同时提供事件触发时的`handler`，\b 发送请求给事件多路复用器是一个非阻塞的操作，发送后立即返回到应用。\n2.  当一组 I/O 操作完成，事件多路复用器会将新来的事件添加到事件队列中。\n3.  此时，事件循环会迭代事件队列中的每个事件。\n4.  对于每个事件，对应的`handler`被处理。\n5.  `handler`，是应用程序代码的一部分，`handler`执行结束后执行权会交回事件循环。但是，在`handler`执行时可能请求新的异步操作，从而新的操作被添加到事件多路复用器。\n6.  当事件队列的全部事件被处理完后，事件多路复用器再次阻塞直到有一个新的事件触发。\n\n现在来定义 Node.js 的核心模式：  \n`\b模式(reactor)`这样处理 I/O，阻塞直到有新的事件从被观察的资源中触发，然后将事件派发给相应的`handler`。\n\n### Node.js 非阻塞 I/O 引擎——libuv\n\n每个操作系统都有不同的接口来实现事件多路复用器，Linux 是 epoll，Mac OSX 是 kqueue，Windows 的 IOCP API，即使是在相同的操作系统中对于不同资源的I/O操作也不同，所以Node.js使用`libuv`来统一处理I/O操作，来达到兼容不同操作系统的目的。\n\n### Node.js 架构\n\n![Node.js 架构](/assets/img/node_architecture.png)\n","slug":"Node-js-设计模式读书笔记-第一章","published":1,"updated":"2018-05-18T07:36:26.068Z","_id":"cjh692bwh0000mzfy23pac4wc","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Welcome-to-the-Node-js-Platform\"><a href=\"#Welcome-to-the-Node-js-Platform\" class=\"headerlink\" title=\"Welcome to the Node.js Platform\"></a>Welcome to the Node.js Platform</h1><h2 id=\"Small-modules-小模块\"><a href=\"#Small-modules-小模块\" class=\"headerlink\" title=\"Small modules(小模块)\"></a>Small modules(小模块)</h2><p><code>Node.js</code>使用<code>module</code>(模块)的概念组织代码的结构。<br>\b<code>package</code>可提供复用的模块，有一个 module 作为入口。<br><code>Node.js</code>中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：</p>\n<a id=\"more\"></a>\n<blockquote>\n<ul>\n<li>“Small is beautiful.”(小而精)</li>\n<li>“Make each program do one thing well.” (每个程序只有单一的职责)</li>\n</ul>\n</blockquote>\n<p><code>Node.js</code> 通过官方包管理工具<code>npm</code>解决包之间的依赖问题，每个<code>package\b</code>都有它自己的依赖，故而一个程序中多个<code>package</code>能够无冲突地安装。应用程序都是由一个个很小的、单职责的依赖构成的。</p>\n<p><strong>小模块</strong>应该有的特性：</p>\n<blockquote>\n<ul>\n<li>Easier to understand and use(易理解、易用)</li>\n<li>Simpler to test and maintain(易于测试和维护)</li>\n<li>Perfect to share with the browser(完美支持浏览器)</li>\n</ul>\n</blockquote>\n<p><strong>DRY(Dont’t Repeat Yourself)原则</strong></p>\n<h2 id=\"Small-surface-area-暴露需要的接口\"><a href=\"#Small-surface-area-暴露需要的接口\" class=\"headerlink\" title=\"Small surface area(暴露需要的接口)\"></a>Small surface area(暴露需要的接口)</h2><p>一般使用者只会用到很有限的功能，而很少去 \b 扩展一个模块，所以<code>Node.js</code>的很多模块只会暴露一个函数或者一个构造器，然后把更细节的东西都放在函数或者构造器里，这样能帮助 \b 使用者认清什么是主要的什么是次要的.</p>\n<p>模块是不允许被扩展的，看起来扩展性低，但实际上有很多优势：减少了应用场景(这样考虑的情况就少了，容易实现)，简化了实现，便于维护，提高了可用性。</p>\n<h2 id=\"Simplicity-and-progmatism-简单而实用\"><a href=\"#Simplicity-and-progmatism-简单而实用\" class=\"headerlink\" title=\"Simplicity and progmatism(简单而实用)\"></a>Simplicity and progmatism(简单而实用)</h2><blockquote>\n<p>简单就是复杂到极致。—— 达尔文</p>\n</blockquote>\n<blockquote>\n<p>设计必须简单，\b 不管是实现还是接口。实现的简洁比接口的简洁更重要。设计中最重要的就是简洁。—— Richard P.Gabriel(一位杰出的计算机科学家)</p>\n</blockquote>\n<p>设计简单的而不是完美或功能完备的软件是一个好的实践：</p>\n<ul>\n<li>\b 更容易实现</li>\n<li>更少的资源，传输更快</li>\n<li>更容易适应</li>\n<li>容易维护和理解</li>\n</ul>\n<p>设计简单这个原则同样也适用于<code>JavaScript</code>，简单函数、闭包、<code>object</code>替代了复杂的类继承。</p>\n<h2 id=\"Introduction-to-Node-js-6-and-ES2015-介绍-Node-js-6-和-ES6\"><a href=\"#Introduction-to-Node-js-6-and-ES2015-介绍-Node-js-6-和-ES6\" class=\"headerlink\" title=\"Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)\"></a>Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)</h2><h3 id=\"The-let-and-const-keywords-let-和-const-关键字\"><a href=\"#The-let-and-const-keywords-let-和-const-关键字\" class=\"headerlink\" title=\"The let and const keywords(let 和 const 关键字)\"></a>The let and const keywords(let 和 const 关键字)</h3><p>在之前(ES2015 之前)，<code>js</code>只支持函数作用域和全局作用域，例如在 if 中声明一个变量却能在 if 块之外访问：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x) <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p>但是使用<code>let</code>关键字后，if 块外就访问不到其中声明的变量了，这在一定程度上能减少因为误操作其中的变量而导致的 bug：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x) <span class=\"comment\">//ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>\n<p><code>const</code>关键字用于声明不可变变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"string\">'This will never change'</span></span><br><span class=\"line\">x = <span class=\"string\">'...'</span></span><br><span class=\"line\"><span class=\"comment\">//TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的是，\b<code>const</code> \b 是意味着变量的绑定不变而不是内容不变，示例入下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt x = &#123;&#125;</span><br><span class=\"line\">x.name = <span class=\"string\">'John'</span><span class=\"comment\">//work</span></span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"literal\">null</span><span class=\"comment\">//don't work</span></span><br></pre></td></tr></table></figure>\n<p>通常来说引入模块使用 \b<code>const</code>防止模块发生变化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> path = <span class=\"string\">'./some/path'</span> <span class=\"comment\">//fail</span></span><br></pre></td></tr></table></figure>\n<p>如果你想要创建一个不可更改的对象，<code>const</code>是不够的，你可以使用 ES5 的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" target=\"_blank\" rel=\"noopener\">Object.freeze()</a>或者 \b<a href=\"https://www.npmjs.com/package/deep-freeze\" target=\"_blank\" rel=\"noopener\">deep-freeze</a>模块，或者我使用<code>react</code>框架时候经常用的<a href=\"https://www.npmjs.com/package/immutable\" target=\"_blank\" rel=\"noopener\">immutable</a>模块也可以。</p>\n<blockquote>\n<p>扩展——这里提一下<strong>ES5</strong>中<code>freeze</code>和<code>seal</code>的区别，<code>seal</code>只限制无法增加和删除对象属性 \b，而<code>freeze</code>在<code>seal</code>的基础上还限制了不可更改对象的属性。</p>\n</blockquote>\n<h3 id=\"The-arrow-function-箭头函数\"><a href=\"#The-arrow-function-箭头函数\" class=\"headerlink\" title=\"The arrow function(箭头函数)\"></a>The arrow function(箭头函数)</h3><p>箭头函数是<strong>ES6</strong>的一大亮点，能很大程度上简化代码。一个参数可以不需要圆括号，函数体只有一行且结果为返回值可不需要花括号，具体示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> event = numbers.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> event2 = numbers.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>箭头函数中 this 的指向跟随父函数，示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DelayedGreeter</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DelayedGreeter.prototype.greet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cb</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> DelayedGreeter(<span class=\"string\">'World'</span>).greet() <span class=\"comment\">//Hello undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">DelayedGreeter.prototype.greet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span> + <span class=\"keyword\">this</span>.name))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> DelayedGreeter(<span class=\"string\">'World'</span>).greet() <span class=\"comment\">//Hello World</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Class-syntax-Class-语法\"><a href=\"#Class-syntax-Class-语法\" class=\"headerlink\" title=\"Class syntax(Class 语法)\"></a>Class syntax(Class 语法)</h3><p><code>class</code>只是个语法糖，使用 class 实现对象继承并不是通过<code>class</code>继承的，还是通过内部的 prototypes，properties 实现继承，但是<code>class</code>使得程序可读性变强了。</p>\n<p>让我们来看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//复杂，晦涩难懂</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, surname, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.surname = surname</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.getFullName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.surname</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.older = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">person1, person2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> preson1.age &gt;= person2.age ? person1 : person2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//易懂</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, surname, age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.surname = surname</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getFullName() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.surname</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> older(person1, person2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> preson1.age &gt;= person2.age ? person1 : person2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonWithMiddlename</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, middlename, surname, age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name, surname, age)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middlename = middlename</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getFullName() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.middlename + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.surname</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Enhanced-object-literals-对象字面量语法增强\"><a href=\"#Enhanced-object-literals-对象字面量语法增强\" class=\"headerlink\" title=\"Enhanced object literals(对象字面量语法增强)\"></a>Enhanced object literals(对象字面量语法增强)</h3><ul>\n<li>缺省键值，属性名和变量名相同时可省略属性名</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"number\">22</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> y = <span class=\"number\">17</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; x, y &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>计算属性，属性可以是由变量计算而来</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> namespace = <span class=\"string\">'-webkit-'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> style = &#123;</span><br><span class=\"line\">  [namespace + <span class=\"string\">'box-sizing'</span>]: <span class=\"string\">'border-box'</span>,</span><br><span class=\"line\">  [namespace + <span class=\"string\">'box-shadow'</span>]: <span class=\"string\">'10px 10px 5px #888888'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>getter 和 setter</li>\n</ul>\n<p>先看例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'George'</span>,</span><br><span class=\"line\">  surname: <span class=\"string\">'Boole'</span>,</span><br><span class=\"line\">  get fullname() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">''</span> + <span class=\"keyword\">this</span>.surname</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set fullname(fullname) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> parts = fullname.split(<span class=\"string\">''</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = parts[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.surname = parts[<span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.fullname) <span class=\"comment\">// \"George Boole\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((person.fullname = <span class=\"string\">'Alan Turing'</span>)) <span class=\"comment\">// \"Alan Turing\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name) <span class=\"comment\">// \"Alan\"</span></span><br></pre></td></tr></table></figure>\n<p>可以看到第二个 console.log 输出的是“Alan Turing”，这是因为调用 set 后默认返回 get 获得的值。</p>\n<h3 id=\"Map-and-Set-collections-Map-和-Set-集合\"><a href=\"#Map-and-Set-collections-Map-和-Set-集合\" class=\"headerlink\" title=\"Map and Set collections(Map 和 Set 集合)\"></a>Map and Set collections(Map 和 Set 集合)</h3><p>原来我们建立 hash map 的时候都是用<code>object</code>来完成的，而现在可以直接使用<code>Map</code>原型，提供了 set、get、has、delete 方法和 size 属性，比使用<code>object</code>更加直接、简单，遍历可使用<code>for...of</code>语法，这种遍历方式是和 Map 中属性的插入顺序是一样的(这在普通<code>object</code>中是无法保证的)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tests = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">   tests.set(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">2</span>+<span class=\"number\">2</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">   tests.set(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">2</span>*<span class=\"number\">2</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">   tests.set(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">2</span>/<span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> entry <span class=\"keyword\">of</span> tests) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log((entry[<span class=\"number\">0</span>]() === entry[<span class=\"number\">1</span>])   <span class=\"string\">'PASS'</span> : <span class=\"string\">'FAIL'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Set</code>只允许存在不同的值，和数学上的集合是一个概念，里面内容可以是<code>number</code>也可以是<code>object</code>或<code>function</code>，除了 set 换成 add 外其他的都与 map 相同，遍历时每一个 entry 内容是 value。</p>\n<h3 id=\"WeakMap-and-WeakSet-collections\"><a href=\"#WeakMap-and-WeakSet-collections\" class=\"headerlink\" title=\"WeakMap and WeakSet collections\"></a>WeakMap and WeakSet collections</h3><p>顾名思义，<code>WeakMap</code>和<code>WeakSet</code>是<code>Map</code>和<code>Set</code>弱化后的原型，但是这其中并无优劣之分，只是适用于不同的场合。</p>\n<p><code>WeakMap</code>的<strong>key</strong>只能是非空对象，对<strong>key</strong>仅保持弱引用，最大的好处是可以避免内存泄漏，一旦<strong>key</strong>的引用为空或者 undefined，垃圾回收器就可以回收这个对象，但是<code>WeakMap</code>不能迭代遍历。</p>\n<p><code>WeakSet</code>与<code>WeakMap</code>同。</p>\n<h3 id=\"Template-literals-模板字符串\"><a href=\"#Template-literals-模板字符串\" class=\"headerlink\" title=\"Template literals(模板字符串)\"></a>Template literals(模板字符串)</h3><p>使用`代替双引号和单引号，在字符串中可以使用表达式${expression}，可以换行。</p>\n<h3 id=\"ES6-其他语法\"><a href=\"#ES6-其他语法\" class=\"headerlink\" title=\"ES6 其他语法\"></a>ES6 其他语法</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Promise</a>(稍后会详细讲到)</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters\" target=\"_blank\" rel=\"noopener\">函数默认参数</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Rest_parameters\" target=\"_blank\" rel=\"noopener\">剩余参数语法</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">拓展运算符</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"noopener\">解构赋值</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target\" target=\"_blank\" rel=\"noopener\">new.target</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" rel=\"noopener\">代理</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\" target=\"_blank\" rel=\"noopener\">反射</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Symbol\" target=\"_blank\" rel=\"noopener\">Symbol</a></li>\n</ul>\n<h2 id=\"The-reactor-pattern\"><a href=\"#The-reactor-pattern\" class=\"headerlink\" title=\"The reactor pattern\"></a>The reactor pattern</h2><p><code>reactor</code>模式是 <code>Node.js</code> 异步的核心。</p>\n<h3 id=\"I-O-is-slow-I-O-操作是慢的\"><a href=\"#I-O-is-slow-I-O-操作是慢的\" class=\"headerlink\" title=\"I/O is slow(I/O 操作是慢的)\"></a>I/O is slow(I/O 操作是慢的)</h3><p>I/O 操作可以说是计算机操作中最慢的一环，I/O 的速度可能和网络速度、磁盘速率有关，也可能和其他因素有关，比如用户点击事件等等。</p>\n<h3 id=\"Blocking-I-O-阻塞-I-O\"><a href=\"#Blocking-I-O-阻塞-I-O\" class=\"headerlink\" title=\"Blocking I/O(阻塞 I/O)\"></a>Blocking I/O(阻塞 I/O)</h3><p>传统的阻塞 I/O 模型中，I/O 请求会阻塞之后代码块的运行，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直到请求完成，数据可用，线程都是阻塞的</span></span><br><span class=\"line\">data = socket.read()</span><br><span class=\"line\"><span class=\"comment\">// 请求完成，数据可用</span></span><br><span class=\"line\">print(data)</span><br></pre></td></tr></table></figure>\n<p>而为了达到并发的 \b 目的，传统的 web 服务器是 \b 选择新开一个线程或进程，这样因为线程(或进程)之间的相互独立性，一个线程(或进程)阻塞并不会影响另一个。</p>\n<p>但是创建一个线程是昂贵的，一个线程需要内存，而且切换线程需要保留线程的上下文等等，所以这种方式并不是最佳实践。</p>\n<h3 id=\"Non-blocking-I-O-非阻塞-I-O\"><a href=\"#Non-blocking-I-O-非阻塞-I-O\" class=\"headerlink\" title=\"Non-blocking I/O(非阻塞 I/O)\"></a>Non-blocking I/O(非阻塞 I/O)</h3><p>与阻塞 I/O 相反，遇到 I/O 请求不会阻塞后续代码的执行，如果访问的资源不可用则会返回一个预定义的常量值。</p>\n<p>非阻塞 I/O 最基本的模式是轮询直到有数据已经返回了，也叫做 \b<code>忙等待</code>模式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resources = [socketA, socketB, pipeA]</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!resources.isEmpty()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; resources.length; i++) &#123;</span><br><span class=\"line\">    resource = resources[i]</span><br><span class=\"line\">    <span class=\"comment\">// 进行读操作</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = resource.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data === NO_DATA_AVAILABLE) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 此时还没有数据</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 资源被释放，从队列中移除该链接</span></span><br><span class=\"line\">      resources.remove(i)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      consumeData(data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子已经能有单线程处理多个请求了，\b 但是不够高效，资源不可用时循环占了太多了 CPU 时间，轮询算法 \b 浪费 CPU 时间。</p>\n<h3 id=\"Event-demultiplexing-事件多路复用\"><a href=\"#Event-demultiplexing-事件多路复用\" class=\"headerlink\" title=\"Event demultiplexing(事件多路复用)\"></a>Event demultiplexing(事件多路复用)</h3><p>对于获取非阻塞的资源而言，忙等待模型不是一个理想的技术，大多数现代的操作系统都提供了一种机制来处理并发和非阻塞资源，这个机制被称为<code>同步多路复用</code>。</p>\n<p>这个组件从一系列被监听的资源中收集 I/O 事件并放入队列中，而且会一直处于阻塞状态直到有新的事件可以被处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socketA, pipeB;</span><br><span class=\"line\">wachedList.add(socketA, FOR_READ);</span><br><span class=\"line\">wachedList.add(pipeB, FOR_READ);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(events = demultiplexer.watch(wachedList)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 事件循环</span></span><br><span class=\"line\">  foreach(event <span class=\"keyword\">in</span> events) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 永远不会阻塞，并且总会有返回值</span></span><br><span class=\"line\">    data = event.resource.read();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 资源已经被释放，从观察者队列移除</span></span><br><span class=\"line\">      demultiplexer.unwatch(event.resource);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获得数据进行处理</span></span><br><span class=\"line\">      consumeData(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码的三个重要步骤：</p>\n<ol>\n<li>资源被添加到一个数据结构中，为每个资源关联一个特定的操作，在这个例子中是 read。</li>\n<li>事件通知器由一组被观察的资源组成，事件通知器是同步和阻塞的直到有资源可以被<code>read</code>，事件触发后会从调用中返回，之后这些事件可以被处理。</li>\n<li>多路复用器返回的每个事件被处理，此时，和事件相关的资源都可用且不会在操作中阻塞。当所有的事件都被处理完后，继续进入循环等待下一个可以被处理的事件。这个被称作为<code>事件循环</code>。</li>\n</ol>\n<p><img src=\"/assets/img/node_demultiplexer.png\" alt=\"多路复用\"></p>\n<p>上图帮助我们理解如何在一个单线程中使用多路复用器和非阻塞 I/O 来处理并发。我们能够看到，只使用一个线程并不会影响我们处理多个 I/O 任务的性能。同时，我们看到任务是在单个线程中随着时间的推移而展开的，而不是分散在多个线程中。我们看到，在单线程中传播的任务相对于多线程中传播的任务反而节约了线程的总体空闲时间，并且更利于程序员编写代码。</p>\n<h3 id=\"Introducing-to-reactor-pattern-reactor-模式的介绍\"><a href=\"#Introducing-to-reactor-pattern-reactor-模式的介绍\" class=\"headerlink\" title=\"Introducing to reactor pattern(reactor 模式的介绍)\"></a>Introducing to reactor pattern(reactor 模式的介绍)</h3><p>主要思想就是每一个 I/O 操作都有一个<code>handler</code>或者成为回调函数(<code>callback</code>)，当事件发生并且被<code>事件循环</code>处理后，这个回调函数就会被调用：</p>\n<p><img src=\"/assets/img/event_loop.png\" alt=\"event loop\"></p>\n<p>一个应用使用<code>reactor</code>模式后：</p>\n<ol>\n<li>应用提交一个请求给事件多路复用器 \b，生成 I/O 操作，同时提供事件触发时的<code>handler</code>，\b 发送请求给事件多路复用器是一个非阻塞的操作，发送后立即返回到应用。</li>\n<li>当一组 I/O 操作完成，事件多路复用器会将新来的事件添加到事件队列中。</li>\n<li>此时，事件循环会迭代事件队列中的每个事件。</li>\n<li>对于每个事件，对应的<code>handler</code>被处理。</li>\n<li><code>handler</code>，是应用程序代码的一部分，<code>handler</code>执行结束后执行权会交回事件循环。但是，在<code>handler</code>执行时可能请求新的异步操作，从而新的操作被添加到事件多路复用器。</li>\n<li>当事件队列的全部事件被处理完后，事件多路复用器再次阻塞直到有一个新的事件触发。</li>\n</ol>\n<p>现在来定义 Node.js 的核心模式：<br><code>\b模式(reactor)</code>这样处理 I/O，阻塞直到有新的事件从被观察的资源中触发，然后将事件派发给相应的<code>handler</code>。</p>\n<h3 id=\"Node-js-非阻塞-I-O-引擎——libuv\"><a href=\"#Node-js-非阻塞-I-O-引擎——libuv\" class=\"headerlink\" title=\"Node.js 非阻塞 I/O 引擎——libuv\"></a>Node.js 非阻塞 I/O 引擎——libuv</h3><p>每个操作系统都有不同的接口来实现事件多路复用器，Linux 是 epoll，Mac OSX 是 kqueue，Windows 的 IOCP API，即使是在相同的操作系统中对于不同资源的I/O操作也不同，所以Node.js使用<code>libuv</code>来统一处理I/O操作，来达到兼容不同操作系统的目的。</p>\n<h3 id=\"Node-js-架构\"><a href=\"#Node-js-架构\" class=\"headerlink\" title=\"Node.js 架构\"></a>Node.js 架构</h3><p><img src=\"/assets/img/node_architecture.png\" alt=\"Node.js 架构\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Welcome-to-the-Node-js-Platform\"><a href=\"#Welcome-to-the-Node-js-Platform\" class=\"headerlink\" title=\"Welcome to the Node.js Platform\"></a>Welcome to the Node.js Platform</h1><h2 id=\"Small-modules-小模块\"><a href=\"#Small-modules-小模块\" class=\"headerlink\" title=\"Small modules(小模块)\"></a>Small modules(小模块)</h2><p><code>Node.js</code>使用<code>module</code>(模块)的概念组织代码的结构。<br>\b<code>package</code>可提供复用的模块，有一个 module 作为入口。<br><code>Node.js</code>中，致力于设计小模块，为了代码的简洁，更为了更好地控制作用域。有两个主要原则：</p>","more":"<blockquote>\n<ul>\n<li>“Small is beautiful.”(小而精)</li>\n<li>“Make each program do one thing well.” (每个程序只有单一的职责)</li>\n</ul>\n</blockquote>\n<p><code>Node.js</code> 通过官方包管理工具<code>npm</code>解决包之间的依赖问题，每个<code>package\b</code>都有它自己的依赖，故而一个程序中多个<code>package</code>能够无冲突地安装。应用程序都是由一个个很小的、单职责的依赖构成的。</p>\n<p><strong>小模块</strong>应该有的特性：</p>\n<blockquote>\n<ul>\n<li>Easier to understand and use(易理解、易用)</li>\n<li>Simpler to test and maintain(易于测试和维护)</li>\n<li>Perfect to share with the browser(完美支持浏览器)</li>\n</ul>\n</blockquote>\n<p><strong>DRY(Dont’t Repeat Yourself)原则</strong></p>\n<h2 id=\"Small-surface-area-暴露需要的接口\"><a href=\"#Small-surface-area-暴露需要的接口\" class=\"headerlink\" title=\"Small surface area(暴露需要的接口)\"></a>Small surface area(暴露需要的接口)</h2><p>一般使用者只会用到很有限的功能，而很少去 \b 扩展一个模块，所以<code>Node.js</code>的很多模块只会暴露一个函数或者一个构造器，然后把更细节的东西都放在函数或者构造器里，这样能帮助 \b 使用者认清什么是主要的什么是次要的.</p>\n<p>模块是不允许被扩展的，看起来扩展性低，但实际上有很多优势：减少了应用场景(这样考虑的情况就少了，容易实现)，简化了实现，便于维护，提高了可用性。</p>\n<h2 id=\"Simplicity-and-progmatism-简单而实用\"><a href=\"#Simplicity-and-progmatism-简单而实用\" class=\"headerlink\" title=\"Simplicity and progmatism(简单而实用)\"></a>Simplicity and progmatism(简单而实用)</h2><blockquote>\n<p>简单就是复杂到极致。—— 达尔文</p>\n</blockquote>\n<blockquote>\n<p>设计必须简单，\b 不管是实现还是接口。实现的简洁比接口的简洁更重要。设计中最重要的就是简洁。—— Richard P.Gabriel(一位杰出的计算机科学家)</p>\n</blockquote>\n<p>设计简单的而不是完美或功能完备的软件是一个好的实践：</p>\n<ul>\n<li>\b 更容易实现</li>\n<li>更少的资源，传输更快</li>\n<li>更容易适应</li>\n<li>容易维护和理解</li>\n</ul>\n<p>设计简单这个原则同样也适用于<code>JavaScript</code>，简单函数、闭包、<code>object</code>替代了复杂的类继承。</p>\n<h2 id=\"Introduction-to-Node-js-6-and-ES2015-介绍-Node-js-6-和-ES6\"><a href=\"#Introduction-to-Node-js-6-and-ES2015-介绍-Node-js-6-和-ES6\" class=\"headerlink\" title=\"Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)\"></a>Introduction to Node.js 6 and ES2015 (介绍 Node.js 6 和 ES6)</h2><h3 id=\"The-let-and-const-keywords-let-和-const-关键字\"><a href=\"#The-let-and-const-keywords-let-和-const-关键字\" class=\"headerlink\" title=\"The let and const keywords(let 和 const 关键字)\"></a>The let and const keywords(let 和 const 关键字)</h3><p>在之前(ES2015 之前)，<code>js</code>只支持函数作用域和全局作用域，例如在 if 中声明一个变量却能在 if 块之外访问：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x) <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p>但是使用<code>let</code>关键字后，if 块外就访问不到其中声明的变量了，这在一定程度上能减少因为误操作其中的变量而导致的 bug：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x) <span class=\"comment\">//ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>\n<p><code>const</code>关键字用于声明不可变变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"string\">'This will never change'</span></span><br><span class=\"line\">x = <span class=\"string\">'...'</span></span><br><span class=\"line\"><span class=\"comment\">//TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的是，\b<code>const</code> \b 是意味着变量的绑定不变而不是内容不变，示例入下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cosnt x = &#123;&#125;</span><br><span class=\"line\">x.name = <span class=\"string\">'John'</span><span class=\"comment\">//work</span></span><br><span class=\"line\"></span><br><span class=\"line\">x = <span class=\"literal\">null</span><span class=\"comment\">//don't work</span></span><br></pre></td></tr></table></figure>\n<p>通常来说引入模块使用 \b<code>const</code>防止模块发生变化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> path = <span class=\"string\">'./some/path'</span> <span class=\"comment\">//fail</span></span><br></pre></td></tr></table></figure>\n<p>如果你想要创建一个不可更改的对象，<code>const</code>是不够的，你可以使用 ES5 的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" target=\"_blank\" rel=\"noopener\">Object.freeze()</a>或者 \b<a href=\"https://www.npmjs.com/package/deep-freeze\" target=\"_blank\" rel=\"noopener\">deep-freeze</a>模块，或者我使用<code>react</code>框架时候经常用的<a href=\"https://www.npmjs.com/package/immutable\" target=\"_blank\" rel=\"noopener\">immutable</a>模块也可以。</p>\n<blockquote>\n<p>扩展——这里提一下<strong>ES5</strong>中<code>freeze</code>和<code>seal</code>的区别，<code>seal</code>只限制无法增加和删除对象属性 \b，而<code>freeze</code>在<code>seal</code>的基础上还限制了不可更改对象的属性。</p>\n</blockquote>\n<h3 id=\"The-arrow-function-箭头函数\"><a href=\"#The-arrow-function-箭头函数\" class=\"headerlink\" title=\"The arrow function(箭头函数)\"></a>The arrow function(箭头函数)</h3><p>箭头函数是<strong>ES6</strong>的一大亮点，能很大程度上简化代码。一个参数可以不需要圆括号，函数体只有一行且结果为返回值可不需要花括号，具体示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> event = numbers.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> event2 = numbers.filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>箭头函数中 this 的指向跟随父函数，示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DelayedGreeter</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DelayedGreeter.prototype.greet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cb</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> DelayedGreeter(<span class=\"string\">'World'</span>).greet() <span class=\"comment\">//Hello undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">DelayedGreeter.prototype.greet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span> + <span class=\"keyword\">this</span>.name))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> DelayedGreeter(<span class=\"string\">'World'</span>).greet() <span class=\"comment\">//Hello World</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Class-syntax-Class-语法\"><a href=\"#Class-syntax-Class-语法\" class=\"headerlink\" title=\"Class syntax(Class 语法)\"></a>Class syntax(Class 语法)</h3><p><code>class</code>只是个语法糖，使用 class 实现对象继承并不是通过<code>class</code>继承的，还是通过内部的 prototypes，properties 实现继承，但是<code>class</code>使得程序可读性变强了。</p>\n<p>让我们来看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//复杂，晦涩难懂</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, surname, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.surname = surname</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.getFullName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.surname</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.older = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">person1, person2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> preson1.age &gt;= person2.age ? person1 : person2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//易懂</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, surname, age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.surname = surname</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getFullName() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.surname</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> older(person1, person2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> preson1.age &gt;= person2.age ? person1 : person2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonWithMiddlename</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name, middlename, surname, age) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name, surname, age)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.middlename = middlename</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getFullName() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.middlename + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.surname</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Enhanced-object-literals-对象字面量语法增强\"><a href=\"#Enhanced-object-literals-对象字面量语法增强\" class=\"headerlink\" title=\"Enhanced object literals(对象字面量语法增强)\"></a>Enhanced object literals(对象字面量语法增强)</h3><ul>\n<li>缺省键值，属性名和变量名相同时可省略属性名</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"number\">22</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> y = <span class=\"number\">17</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; x, y &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>计算属性，属性可以是由变量计算而来</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> namespace = <span class=\"string\">'-webkit-'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> style = &#123;</span><br><span class=\"line\">  [namespace + <span class=\"string\">'box-sizing'</span>]: <span class=\"string\">'border-box'</span>,</span><br><span class=\"line\">  [namespace + <span class=\"string\">'box-shadow'</span>]: <span class=\"string\">'10px 10px 5px #888888'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>getter 和 setter</li>\n</ul>\n<p>先看例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'George'</span>,</span><br><span class=\"line\">  surname: <span class=\"string\">'Boole'</span>,</span><br><span class=\"line\">  get fullname() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">''</span> + <span class=\"keyword\">this</span>.surname</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set fullname(fullname) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> parts = fullname.split(<span class=\"string\">''</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = parts[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.surname = parts[<span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.fullname) <span class=\"comment\">// \"George Boole\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((person.fullname = <span class=\"string\">'Alan Turing'</span>)) <span class=\"comment\">// \"Alan Turing\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name) <span class=\"comment\">// \"Alan\"</span></span><br></pre></td></tr></table></figure>\n<p>可以看到第二个 console.log 输出的是“Alan Turing”，这是因为调用 set 后默认返回 get 获得的值。</p>\n<h3 id=\"Map-and-Set-collections-Map-和-Set-集合\"><a href=\"#Map-and-Set-collections-Map-和-Set-集合\" class=\"headerlink\" title=\"Map and Set collections(Map 和 Set 集合)\"></a>Map and Set collections(Map 和 Set 集合)</h3><p>原来我们建立 hash map 的时候都是用<code>object</code>来完成的，而现在可以直接使用<code>Map</code>原型，提供了 set、get、has、delete 方法和 size 属性，比使用<code>object</code>更加直接、简单，遍历可使用<code>for...of</code>语法，这种遍历方式是和 Map 中属性的插入顺序是一样的(这在普通<code>object</code>中是无法保证的)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tests = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">   tests.set(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">2</span>+<span class=\"number\">2</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">   tests.set(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">2</span>*<span class=\"number\">2</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">   tests.set(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">2</span>/<span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> entry <span class=\"keyword\">of</span> tests) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log((entry[<span class=\"number\">0</span>]() === entry[<span class=\"number\">1</span>])   <span class=\"string\">'PASS'</span> : <span class=\"string\">'FAIL'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Set</code>只允许存在不同的值，和数学上的集合是一个概念，里面内容可以是<code>number</code>也可以是<code>object</code>或<code>function</code>，除了 set 换成 add 外其他的都与 map 相同，遍历时每一个 entry 内容是 value。</p>\n<h3 id=\"WeakMap-and-WeakSet-collections\"><a href=\"#WeakMap-and-WeakSet-collections\" class=\"headerlink\" title=\"WeakMap and WeakSet collections\"></a>WeakMap and WeakSet collections</h3><p>顾名思义，<code>WeakMap</code>和<code>WeakSet</code>是<code>Map</code>和<code>Set</code>弱化后的原型，但是这其中并无优劣之分，只是适用于不同的场合。</p>\n<p><code>WeakMap</code>的<strong>key</strong>只能是非空对象，对<strong>key</strong>仅保持弱引用，最大的好处是可以避免内存泄漏，一旦<strong>key</strong>的引用为空或者 undefined，垃圾回收器就可以回收这个对象，但是<code>WeakMap</code>不能迭代遍历。</p>\n<p><code>WeakSet</code>与<code>WeakMap</code>同。</p>\n<h3 id=\"Template-literals-模板字符串\"><a href=\"#Template-literals-模板字符串\" class=\"headerlink\" title=\"Template literals(模板字符串)\"></a>Template literals(模板字符串)</h3><p>使用`代替双引号和单引号，在字符串中可以使用表达式${expression}，可以换行。</p>\n<h3 id=\"ES6-其他语法\"><a href=\"#ES6-其他语法\" class=\"headerlink\" title=\"ES6 其他语法\"></a>ES6 其他语法</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Promise</a>(稍后会详细讲到)</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters\" target=\"_blank\" rel=\"noopener\">函数默认参数</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Rest_parameters\" target=\"_blank\" rel=\"noopener\">剩余参数语法</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">拓展运算符</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"noopener\">解构赋值</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target\" target=\"_blank\" rel=\"noopener\">new.target</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" rel=\"noopener\">代理</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\" target=\"_blank\" rel=\"noopener\">反射</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Symbol\" target=\"_blank\" rel=\"noopener\">Symbol</a></li>\n</ul>\n<h2 id=\"The-reactor-pattern\"><a href=\"#The-reactor-pattern\" class=\"headerlink\" title=\"The reactor pattern\"></a>The reactor pattern</h2><p><code>reactor</code>模式是 <code>Node.js</code> 异步的核心。</p>\n<h3 id=\"I-O-is-slow-I-O-操作是慢的\"><a href=\"#I-O-is-slow-I-O-操作是慢的\" class=\"headerlink\" title=\"I/O is slow(I/O 操作是慢的)\"></a>I/O is slow(I/O 操作是慢的)</h3><p>I/O 操作可以说是计算机操作中最慢的一环，I/O 的速度可能和网络速度、磁盘速率有关，也可能和其他因素有关，比如用户点击事件等等。</p>\n<h3 id=\"Blocking-I-O-阻塞-I-O\"><a href=\"#Blocking-I-O-阻塞-I-O\" class=\"headerlink\" title=\"Blocking I/O(阻塞 I/O)\"></a>Blocking I/O(阻塞 I/O)</h3><p>传统的阻塞 I/O 模型中，I/O 请求会阻塞之后代码块的运行，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直到请求完成，数据可用，线程都是阻塞的</span></span><br><span class=\"line\">data = socket.read()</span><br><span class=\"line\"><span class=\"comment\">// 请求完成，数据可用</span></span><br><span class=\"line\">print(data)</span><br></pre></td></tr></table></figure>\n<p>而为了达到并发的 \b 目的，传统的 web 服务器是 \b 选择新开一个线程或进程，这样因为线程(或进程)之间的相互独立性，一个线程(或进程)阻塞并不会影响另一个。</p>\n<p>但是创建一个线程是昂贵的，一个线程需要内存，而且切换线程需要保留线程的上下文等等，所以这种方式并不是最佳实践。</p>\n<h3 id=\"Non-blocking-I-O-非阻塞-I-O\"><a href=\"#Non-blocking-I-O-非阻塞-I-O\" class=\"headerlink\" title=\"Non-blocking I/O(非阻塞 I/O)\"></a>Non-blocking I/O(非阻塞 I/O)</h3><p>与阻塞 I/O 相反，遇到 I/O 请求不会阻塞后续代码的执行，如果访问的资源不可用则会返回一个预定义的常量值。</p>\n<p>非阻塞 I/O 最基本的模式是轮询直到有数据已经返回了，也叫做 \b<code>忙等待</code>模式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resources = [socketA, socketB, pipeA]</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!resources.isEmpty()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; resources.length; i++) &#123;</span><br><span class=\"line\">    resource = resources[i]</span><br><span class=\"line\">    <span class=\"comment\">// 进行读操作</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = resource.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data === NO_DATA_AVAILABLE) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 此时还没有数据</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 资源被释放，从队列中移除该链接</span></span><br><span class=\"line\">      resources.remove(i)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      consumeData(data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子已经能有单线程处理多个请求了，\b 但是不够高效，资源不可用时循环占了太多了 CPU 时间，轮询算法 \b 浪费 CPU 时间。</p>\n<h3 id=\"Event-demultiplexing-事件多路复用\"><a href=\"#Event-demultiplexing-事件多路复用\" class=\"headerlink\" title=\"Event demultiplexing(事件多路复用)\"></a>Event demultiplexing(事件多路复用)</h3><p>对于获取非阻塞的资源而言，忙等待模型不是一个理想的技术，大多数现代的操作系统都提供了一种机制来处理并发和非阻塞资源，这个机制被称为<code>同步多路复用</code>。</p>\n<p>这个组件从一系列被监听的资源中收集 I/O 事件并放入队列中，而且会一直处于阻塞状态直到有新的事件可以被处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socketA, pipeB;</span><br><span class=\"line\">wachedList.add(socketA, FOR_READ);</span><br><span class=\"line\">wachedList.add(pipeB, FOR_READ);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(events = demultiplexer.watch(wachedList)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 事件循环</span></span><br><span class=\"line\">  foreach(event <span class=\"keyword\">in</span> events) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 永远不会阻塞，并且总会有返回值</span></span><br><span class=\"line\">    data = event.resource.read();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 资源已经被释放，从观察者队列移除</span></span><br><span class=\"line\">      demultiplexer.unwatch(event.resource);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 获得数据进行处理</span></span><br><span class=\"line\">      consumeData(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码的三个重要步骤：</p>\n<ol>\n<li>资源被添加到一个数据结构中，为每个资源关联一个特定的操作，在这个例子中是 read。</li>\n<li>事件通知器由一组被观察的资源组成，事件通知器是同步和阻塞的直到有资源可以被<code>read</code>，事件触发后会从调用中返回，之后这些事件可以被处理。</li>\n<li>多路复用器返回的每个事件被处理，此时，和事件相关的资源都可用且不会在操作中阻塞。当所有的事件都被处理完后，继续进入循环等待下一个可以被处理的事件。这个被称作为<code>事件循环</code>。</li>\n</ol>\n<p><img src=\"/assets/img/node_demultiplexer.png\" alt=\"多路复用\"></p>\n<p>上图帮助我们理解如何在一个单线程中使用多路复用器和非阻塞 I/O 来处理并发。我们能够看到，只使用一个线程并不会影响我们处理多个 I/O 任务的性能。同时，我们看到任务是在单个线程中随着时间的推移而展开的，而不是分散在多个线程中。我们看到，在单线程中传播的任务相对于多线程中传播的任务反而节约了线程的总体空闲时间，并且更利于程序员编写代码。</p>\n<h3 id=\"Introducing-to-reactor-pattern-reactor-模式的介绍\"><a href=\"#Introducing-to-reactor-pattern-reactor-模式的介绍\" class=\"headerlink\" title=\"Introducing to reactor pattern(reactor 模式的介绍)\"></a>Introducing to reactor pattern(reactor 模式的介绍)</h3><p>主要思想就是每一个 I/O 操作都有一个<code>handler</code>或者成为回调函数(<code>callback</code>)，当事件发生并且被<code>事件循环</code>处理后，这个回调函数就会被调用：</p>\n<p><img src=\"/assets/img/event_loop.png\" alt=\"event loop\"></p>\n<p>一个应用使用<code>reactor</code>模式后：</p>\n<ol>\n<li>应用提交一个请求给事件多路复用器 \b，生成 I/O 操作，同时提供事件触发时的<code>handler</code>，\b 发送请求给事件多路复用器是一个非阻塞的操作，发送后立即返回到应用。</li>\n<li>当一组 I/O 操作完成，事件多路复用器会将新来的事件添加到事件队列中。</li>\n<li>此时，事件循环会迭代事件队列中的每个事件。</li>\n<li>对于每个事件，对应的<code>handler</code>被处理。</li>\n<li><code>handler</code>，是应用程序代码的一部分，<code>handler</code>执行结束后执行权会交回事件循环。但是，在<code>handler</code>执行时可能请求新的异步操作，从而新的操作被添加到事件多路复用器。</li>\n<li>当事件队列的全部事件被处理完后，事件多路复用器再次阻塞直到有一个新的事件触发。</li>\n</ol>\n<p>现在来定义 Node.js 的核心模式：<br><code>\b模式(reactor)</code>这样处理 I/O，阻塞直到有新的事件从被观察的资源中触发，然后将事件派发给相应的<code>handler</code>。</p>\n<h3 id=\"Node-js-非阻塞-I-O-引擎——libuv\"><a href=\"#Node-js-非阻塞-I-O-引擎——libuv\" class=\"headerlink\" title=\"Node.js 非阻塞 I/O 引擎——libuv\"></a>Node.js 非阻塞 I/O 引擎——libuv</h3><p>每个操作系统都有不同的接口来实现事件多路复用器，Linux 是 epoll，Mac OSX 是 kqueue，Windows 的 IOCP API，即使是在相同的操作系统中对于不同资源的I/O操作也不同，所以Node.js使用<code>libuv</code>来统一处理I/O操作，来达到兼容不同操作系统的目的。</p>\n<h3 id=\"Node-js-架构\"><a href=\"#Node-js-架构\" class=\"headerlink\" title=\"Node.js 架构\"></a>Node.js 架构</h3><p><img src=\"/assets/img/node_architecture.png\" alt=\"Node.js 架构\"></p>"},{"title":"VSCode配置","date":"2018-05-05T11:30:34.000Z","_content":"\n最近使用IDE从WebStorm更换到VSCode，故在此记录下VSCode的一些配置，供以后查看。\n\n## 插件篇\n\nVSCode更倾向于定制化，所以需要自行寻找需要的插件，来提高打码的效率~\n\n我这里使用了一些暂时需要用到的插件：\n\n<!-- more -->\n\n### 1. Beautify\n一个很常用的代码格式化工具，一键格式化，非常方便。\n\n### 2. Git History\n\n查看log，文件历史记录等等，在自带git功能上多加了许多功能。\n\n### 3. Vetur\n\nVue的火热使得前端很多时候都使用它来开发，该插件高亮vue代码以及vue的代码格式化。\n\n### 4. Auto Rename Tag\n\n自动重命名tag名称，类似于webstorm中的功能。\n\n### 5. Auto Close Tag\n\n自动关闭tag，类似webstorm。\n\n### 6. CSS Peek\n\n自动识别css文件中的类名，在\b模板中插入class时自动提示。\n\n## 配置篇\n\n记录自己用的：\n\n```js\n{\n    \"git.enableSmartCommit\": true,\n    \"git.autofetch\": true,\n    \"terminal.integrated.shell.osx\": \"zsh\",\n    \"window.zoomLevel\": 0,\n    \"beautify.language\": {\n        \"js\": {\n            \"type\": [\n                \"javascript\",\n                \"json\"\n            ],\n            \"filename\": [\n                \".jshintrc\",\n                \".jsbeautifyrc\"\n            ]\n        },\n        \"css\": [\n            \"css\",\n            \"scss\"\n        ],\n        \"html\": [\n            \"htm\",\n            \"html\",\n            \"vue\"\n        ]\n    },\n    \"html.format.endWithNewline\": true,\n    \"prettier.singleQuote\": true,\n    \"prettier.semi\": false,\n    \"vetur.format.defaultFormatter.html\": \"js-beautify-html\",\n    \"vetur.format.defaultFormatterOptions\": {\n      \"wrap_attributes\": \"force-aligned\"\n    }\n}\n```","source":"_posts/VSCode配置.md","raw":"---\ntitle: VSCode配置\ndate: 2018-05-05 19:30:34\ntags:\n    - 前端\n---\n\n最近使用IDE从WebStorm更换到VSCode，故在此记录下VSCode的一些配置，供以后查看。\n\n## 插件篇\n\nVSCode更倾向于定制化，所以需要自行寻找需要的插件，来提高打码的效率~\n\n我这里使用了一些暂时需要用到的插件：\n\n<!-- more -->\n\n### 1. Beautify\n一个很常用的代码格式化工具，一键格式化，非常方便。\n\n### 2. Git History\n\n查看log，文件历史记录等等，在自带git功能上多加了许多功能。\n\n### 3. Vetur\n\nVue的火热使得前端很多时候都使用它来开发，该插件高亮vue代码以及vue的代码格式化。\n\n### 4. Auto Rename Tag\n\n自动重命名tag名称，类似于webstorm中的功能。\n\n### 5. Auto Close Tag\n\n自动关闭tag，类似webstorm。\n\n### 6. CSS Peek\n\n自动识别css文件中的类名，在\b模板中插入class时自动提示。\n\n## 配置篇\n\n记录自己用的：\n\n```js\n{\n    \"git.enableSmartCommit\": true,\n    \"git.autofetch\": true,\n    \"terminal.integrated.shell.osx\": \"zsh\",\n    \"window.zoomLevel\": 0,\n    \"beautify.language\": {\n        \"js\": {\n            \"type\": [\n                \"javascript\",\n                \"json\"\n            ],\n            \"filename\": [\n                \".jshintrc\",\n                \".jsbeautifyrc\"\n            ]\n        },\n        \"css\": [\n            \"css\",\n            \"scss\"\n        ],\n        \"html\": [\n            \"htm\",\n            \"html\",\n            \"vue\"\n        ]\n    },\n    \"html.format.endWithNewline\": true,\n    \"prettier.singleQuote\": true,\n    \"prettier.semi\": false,\n    \"vetur.format.defaultFormatter.html\": \"js-beautify-html\",\n    \"vetur.format.defaultFormatterOptions\": {\n      \"wrap_attributes\": \"force-aligned\"\n    }\n}\n```","slug":"VSCode配置","published":1,"updated":"2018-05-06T12:50:42.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh692bwn0002mzfyiws7lst9","content":"<p>最近使用IDE从WebStorm更换到VSCode，故在此记录下VSCode的一些配置，供以后查看。</p>\n<h2 id=\"插件篇\"><a href=\"#插件篇\" class=\"headerlink\" title=\"插件篇\"></a>插件篇</h2><p>VSCode更倾向于定制化，所以需要自行寻找需要的插件，来提高打码的效率~</p>\n<p>我这里使用了一些暂时需要用到的插件：</p>\n<a id=\"more\"></a>\n<h3 id=\"1-Beautify\"><a href=\"#1-Beautify\" class=\"headerlink\" title=\"1. Beautify\"></a>1. Beautify</h3><p>一个很常用的代码格式化工具，一键格式化，非常方便。</p>\n<h3 id=\"2-Git-History\"><a href=\"#2-Git-History\" class=\"headerlink\" title=\"2. Git History\"></a>2. Git History</h3><p>查看log，文件历史记录等等，在自带git功能上多加了许多功能。</p>\n<h3 id=\"3-Vetur\"><a href=\"#3-Vetur\" class=\"headerlink\" title=\"3. Vetur\"></a>3. Vetur</h3><p>Vue的火热使得前端很多时候都使用它来开发，该插件高亮vue代码以及vue的代码格式化。</p>\n<h3 id=\"4-Auto-Rename-Tag\"><a href=\"#4-Auto-Rename-Tag\" class=\"headerlink\" title=\"4. Auto Rename Tag\"></a>4. Auto Rename Tag</h3><p>自动重命名tag名称，类似于webstorm中的功能。</p>\n<h3 id=\"5-Auto-Close-Tag\"><a href=\"#5-Auto-Close-Tag\" class=\"headerlink\" title=\"5. Auto Close Tag\"></a>5. Auto Close Tag</h3><p>自动关闭tag，类似webstorm。</p>\n<h3 id=\"6-CSS-Peek\"><a href=\"#6-CSS-Peek\" class=\"headerlink\" title=\"6. CSS Peek\"></a>6. CSS Peek</h3><p>自动识别css文件中的类名，在\b模板中插入class时自动提示。</p>\n<h2 id=\"配置篇\"><a href=\"#配置篇\" class=\"headerlink\" title=\"配置篇\"></a>配置篇</h2><p>记录自己用的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"git.enableSmartCommit\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">\"git.autofetch\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">\"terminal.integrated.shell.osx\"</span>: <span class=\"string\">\"zsh\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"window.zoomLevel\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"string\">\"beautify.language\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"js\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"type\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"json\"</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">\"filename\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\".jshintrc\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\".jsbeautifyrc\"</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"css\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"css\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"scss\"</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"string\">\"html\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"htm\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"html\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"vue\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"html.format.endWithNewline\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">\"prettier.singleQuote\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">\"prettier.semi\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"string\">\"vetur.format.defaultFormatter.html\"</span>: <span class=\"string\">\"js-beautify-html\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"vetur.format.defaultFormatterOptions\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"wrap_attributes\"</span>: <span class=\"string\">\"force-aligned\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>最近使用IDE从WebStorm更换到VSCode，故在此记录下VSCode的一些配置，供以后查看。</p>\n<h2 id=\"插件篇\"><a href=\"#插件篇\" class=\"headerlink\" title=\"插件篇\"></a>插件篇</h2><p>VSCode更倾向于定制化，所以需要自行寻找需要的插件，来提高打码的效率~</p>\n<p>我这里使用了一些暂时需要用到的插件：</p>","more":"<h3 id=\"1-Beautify\"><a href=\"#1-Beautify\" class=\"headerlink\" title=\"1. Beautify\"></a>1. Beautify</h3><p>一个很常用的代码格式化工具，一键格式化，非常方便。</p>\n<h3 id=\"2-Git-History\"><a href=\"#2-Git-History\" class=\"headerlink\" title=\"2. Git History\"></a>2. Git History</h3><p>查看log，文件历史记录等等，在自带git功能上多加了许多功能。</p>\n<h3 id=\"3-Vetur\"><a href=\"#3-Vetur\" class=\"headerlink\" title=\"3. Vetur\"></a>3. Vetur</h3><p>Vue的火热使得前端很多时候都使用它来开发，该插件高亮vue代码以及vue的代码格式化。</p>\n<h3 id=\"4-Auto-Rename-Tag\"><a href=\"#4-Auto-Rename-Tag\" class=\"headerlink\" title=\"4. Auto Rename Tag\"></a>4. Auto Rename Tag</h3><p>自动重命名tag名称，类似于webstorm中的功能。</p>\n<h3 id=\"5-Auto-Close-Tag\"><a href=\"#5-Auto-Close-Tag\" class=\"headerlink\" title=\"5. Auto Close Tag\"></a>5. Auto Close Tag</h3><p>自动关闭tag，类似webstorm。</p>\n<h3 id=\"6-CSS-Peek\"><a href=\"#6-CSS-Peek\" class=\"headerlink\" title=\"6. CSS Peek\"></a>6. CSS Peek</h3><p>自动识别css文件中的类名，在\b模板中插入class时自动提示。</p>\n<h2 id=\"配置篇\"><a href=\"#配置篇\" class=\"headerlink\" title=\"配置篇\"></a>配置篇</h2><p>记录自己用的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"git.enableSmartCommit\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">\"git.autofetch\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">\"terminal.integrated.shell.osx\"</span>: <span class=\"string\">\"zsh\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"window.zoomLevel\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"string\">\"beautify.language\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"js\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"type\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"json\"</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"string\">\"filename\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\".jshintrc\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\".jsbeautifyrc\"</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"css\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"css\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"scss\"</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"string\">\"html\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"htm\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"html\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"vue\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"html.format.endWithNewline\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">\"prettier.singleQuote\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">\"prettier.semi\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"string\">\"vetur.format.defaultFormatter.html\"</span>: <span class=\"string\">\"js-beautify-html\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"vetur.format.defaultFormatterOptions\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"wrap_attributes\"</span>: <span class=\"string\">\"force-aligned\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Python 处理excel文件","date":"2018-05-09T14:42:58.000Z","_content":"\n最近需要用到Python去处理excel，目标是根据用户输入的信息，先显示每列的列名以及这一列示例行（取前两行信息），然后根据输入的列号删除对应的列。\n\n网上搜索了下主要有几种方案：\n\n### 1. 使用xlrd、xlwt、xlutils组合\n\n这种方案比较常见，而且读取和写入速度较快，但是只能操作2003版本之前的xls文件，处理不了xlsx，所以想要处理2003版本之后的请绕道。\n\n> 注意！  \nxlutils复制的excel格式上会存在一些问题，我在使用的时候就因为这个原因而\b弃用了，灰底的表格会变成深蓝色底的，\b难以接受。 \n\n<!-- more -->\n\nxlrd用来读取excel内容，xlwt写入excel内容，xlutils封装了一些常用的操作excel的函数供用户使用，一些使用如下：\n\n```python\n#打开excel文件\nworkbook = xlrd.open_workbook('myexcel.xls')\n#获取表单\nworksheet = workbook.sheet_by_index(0)\n#读取数据\ndata = worksheet.cell_value(0,0)\n##另一种获取数据，但这种是包含数据类型的，需要内容可通过value获取\ndata2 = worksheet.cell(0, 0)\n#----xlwt库\n#新建excel\nwb = xlwt.Workbook()\n#添加工作薄\nsh = wb.add_sheet('Sheet1')\n#写入数据\nsh.write(0,0,'data')\n#保存文件\nwb.save('myexcel.xls')\n#----xlutils库\n#打开excel文件\nbook = xlrd.open_workbook('myexcel.xls')\n#复制一份\nnew_book = xlutils.copy(book)\n#拿到工作薄\nworksheet = new_book.getsheet(0)\n#写入数据\nworksheet.write(0,0,'new data')\n#保存\nnew_book.save()\n```\n\n### 2. 使用openpyxl\n\n与xlrd、xlwt、xlutils组合不同，openpyxl只支持excel 2003之后的也就是xlsx文件，示例如下：\n\n```python\nimport openpyxl\n# 新建文件\nworkbook = openpyxl.Workbook() \n# 写入文件\nsheet = workbook.activesheet['A1']='data'\n# 保存文件 \nworkbook.save('test.xlsx')\n\n#或者\n#打开文件\nwb = openpyxl.load_workbook('test.xlsx')\n#读取数据\nws = wb.active\ncols = ws.columns\ncols[0][1].value = 'data'\n```\n\n### 3. 使用win32com操作系统的\bExcel程序\n\n这种方式约束较多，要求Windows + Microsoft Excel，是使用win32com库来操作Excel程序来完成对excel文件的操作，官方的API特别的复杂，要找到自己需要的API还是要费一番功夫的，但是相应的能做的事也就多了，\b你能在Excel程序中做的事，几乎使用win32com都能做，具体可用的可查看官方的[文档](https://documentation.devexpress.com/OfficeFileAPI/12078/Spreadsheet-Document-API/Examples/Worksheets)，\b几乎和vb\b程序差不多，不用看c++的。\n举\b一些我在项目中用到的例子：\n\n```python\n#打开应用\nxlApp = win32com.client.Dispatch('Excel.Application')\n#打开表格\nxlBook = xlApp.Workbook.Open('test.xls')\n#保存文件\nxlBook.Save()\n#另存为\nxlBook.SaveAs('new.xls')\n#关闭文件\nxlBook.Close(SaveChanges=0)\n#获得sheet，传入sheet名字\nsht = xlBook.Worksheets('Sheet1')\n#获得sheet2，传入index\nsht = xlBook.worksheets[index]\n#获得单元格内容\ndata =  sht.Cells(row, col).Value\n#设置单元格内容\nsht.Cells(row, col).Value = 'New Value'\n#获得一块\nmyRange = sht.Range(sht.Cells(row1, col1), sht.Cells(row2, col2)).Value\n#选择sheet\nsht.Activate\n#获得一列\nsht.Columns(index)\n#删除一列\nsht.Columns(1).Delete()\n```\n\n## 总结\n\n以上就是3种常用操作excel的python库，读者可根据自己的情况选择合适的库。\n","source":"_posts/Python-处理excel文件.md","raw":"---\ntitle: Python 处理excel文件\ndate: 2018-05-09 22:42:58\ntags:\n    - python\n---\n\n最近需要用到Python去处理excel，目标是根据用户输入的信息，先显示每列的列名以及这一列示例行（取前两行信息），然后根据输入的列号删除对应的列。\n\n网上搜索了下主要有几种方案：\n\n### 1. 使用xlrd、xlwt、xlutils组合\n\n这种方案比较常见，而且读取和写入速度较快，但是只能操作2003版本之前的xls文件，处理不了xlsx，所以想要处理2003版本之后的请绕道。\n\n> 注意！  \nxlutils复制的excel格式上会存在一些问题，我在使用的时候就因为这个原因而\b弃用了，灰底的表格会变成深蓝色底的，\b难以接受。 \n\n<!-- more -->\n\nxlrd用来读取excel内容，xlwt写入excel内容，xlutils封装了一些常用的操作excel的函数供用户使用，一些使用如下：\n\n```python\n#打开excel文件\nworkbook = xlrd.open_workbook('myexcel.xls')\n#获取表单\nworksheet = workbook.sheet_by_index(0)\n#读取数据\ndata = worksheet.cell_value(0,0)\n##另一种获取数据，但这种是包含数据类型的，需要内容可通过value获取\ndata2 = worksheet.cell(0, 0)\n#----xlwt库\n#新建excel\nwb = xlwt.Workbook()\n#添加工作薄\nsh = wb.add_sheet('Sheet1')\n#写入数据\nsh.write(0,0,'data')\n#保存文件\nwb.save('myexcel.xls')\n#----xlutils库\n#打开excel文件\nbook = xlrd.open_workbook('myexcel.xls')\n#复制一份\nnew_book = xlutils.copy(book)\n#拿到工作薄\nworksheet = new_book.getsheet(0)\n#写入数据\nworksheet.write(0,0,'new data')\n#保存\nnew_book.save()\n```\n\n### 2. 使用openpyxl\n\n与xlrd、xlwt、xlutils组合不同，openpyxl只支持excel 2003之后的也就是xlsx文件，示例如下：\n\n```python\nimport openpyxl\n# 新建文件\nworkbook = openpyxl.Workbook() \n# 写入文件\nsheet = workbook.activesheet['A1']='data'\n# 保存文件 \nworkbook.save('test.xlsx')\n\n#或者\n#打开文件\nwb = openpyxl.load_workbook('test.xlsx')\n#读取数据\nws = wb.active\ncols = ws.columns\ncols[0][1].value = 'data'\n```\n\n### 3. 使用win32com操作系统的\bExcel程序\n\n这种方式约束较多，要求Windows + Microsoft Excel，是使用win32com库来操作Excel程序来完成对excel文件的操作，官方的API特别的复杂，要找到自己需要的API还是要费一番功夫的，但是相应的能做的事也就多了，\b你能在Excel程序中做的事，几乎使用win32com都能做，具体可用的可查看官方的[文档](https://documentation.devexpress.com/OfficeFileAPI/12078/Spreadsheet-Document-API/Examples/Worksheets)，\b几乎和vb\b程序差不多，不用看c++的。\n举\b一些我在项目中用到的例子：\n\n```python\n#打开应用\nxlApp = win32com.client.Dispatch('Excel.Application')\n#打开表格\nxlBook = xlApp.Workbook.Open('test.xls')\n#保存文件\nxlBook.Save()\n#另存为\nxlBook.SaveAs('new.xls')\n#关闭文件\nxlBook.Close(SaveChanges=0)\n#获得sheet，传入sheet名字\nsht = xlBook.Worksheets('Sheet1')\n#获得sheet2，传入index\nsht = xlBook.worksheets[index]\n#获得单元格内容\ndata =  sht.Cells(row, col).Value\n#设置单元格内容\nsht.Cells(row, col).Value = 'New Value'\n#获得一块\nmyRange = sht.Range(sht.Cells(row1, col1), sht.Cells(row2, col2)).Value\n#选择sheet\nsht.Activate\n#获得一列\nsht.Columns(index)\n#删除一列\nsht.Columns(1).Delete()\n```\n\n## 总结\n\n以上就是3种常用操作excel的python库，读者可根据自己的情况选择合适的库。\n","slug":"Python-处理excel文件","published":1,"updated":"2018-05-10T09:01:45.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh692bws0005mzfytyjo03g9","content":"<p>最近需要用到Python去处理excel，目标是根据用户输入的信息，先显示每列的列名以及这一列示例行（取前两行信息），然后根据输入的列号删除对应的列。</p>\n<p>网上搜索了下主要有几种方案：</p>\n<h3 id=\"1-使用xlrd、xlwt、xlutils组合\"><a href=\"#1-使用xlrd、xlwt、xlutils组合\" class=\"headerlink\" title=\"1. 使用xlrd、xlwt、xlutils组合\"></a>1. 使用xlrd、xlwt、xlutils组合</h3><p>这种方案比较常见，而且读取和写入速度较快，但是只能操作2003版本之前的xls文件，处理不了xlsx，所以想要处理2003版本之后的请绕道。</p>\n<blockquote>\n<p>注意！<br>xlutils复制的excel格式上会存在一些问题，我在使用的时候就因为这个原因而\b弃用了，灰底的表格会变成深蓝色底的，\b难以接受。 </p>\n</blockquote>\n<a id=\"more\"></a>\n<p>xlrd用来读取excel内容，xlwt写入excel内容，xlutils封装了一些常用的操作excel的函数供用户使用，一些使用如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#打开excel文件</span></span><br><span class=\"line\">workbook = xlrd.open_workbook(<span class=\"string\">'myexcel.xls'</span>)</span><br><span class=\"line\"><span class=\"comment\">#获取表单</span></span><br><span class=\"line\">worksheet = workbook.sheet_by_index(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">#读取数据</span></span><br><span class=\"line\">data = worksheet.cell_value(<span class=\"number\">0</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">##另一种获取数据，但这种是包含数据类型的，需要内容可通过value获取</span></span><br><span class=\"line\">data2 = worksheet.cell(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">#----xlwt库</span></span><br><span class=\"line\"><span class=\"comment\">#新建excel</span></span><br><span class=\"line\">wb = xlwt.Workbook()</span><br><span class=\"line\"><span class=\"comment\">#添加工作薄</span></span><br><span class=\"line\">sh = wb.add_sheet(<span class=\"string\">'Sheet1'</span>)</span><br><span class=\"line\"><span class=\"comment\">#写入数据</span></span><br><span class=\"line\">sh.write(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"string\">'data'</span>)</span><br><span class=\"line\"><span class=\"comment\">#保存文件</span></span><br><span class=\"line\">wb.save(<span class=\"string\">'myexcel.xls'</span>)</span><br><span class=\"line\"><span class=\"comment\">#----xlutils库</span></span><br><span class=\"line\"><span class=\"comment\">#打开excel文件</span></span><br><span class=\"line\">book = xlrd.open_workbook(<span class=\"string\">'myexcel.xls'</span>)</span><br><span class=\"line\"><span class=\"comment\">#复制一份</span></span><br><span class=\"line\">new_book = xlutils.copy(book)</span><br><span class=\"line\"><span class=\"comment\">#拿到工作薄</span></span><br><span class=\"line\">worksheet = new_book.getsheet(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">#写入数据</span></span><br><span class=\"line\">worksheet.write(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"string\">'new data'</span>)</span><br><span class=\"line\"><span class=\"comment\">#保存</span></span><br><span class=\"line\">new_book.save()</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用openpyxl\"><a href=\"#2-使用openpyxl\" class=\"headerlink\" title=\"2. 使用openpyxl\"></a>2. 使用openpyxl</h3><p>与xlrd、xlwt、xlutils组合不同，openpyxl只支持excel 2003之后的也就是xlsx文件，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> openpyxl</span><br><span class=\"line\"><span class=\"comment\"># 新建文件</span></span><br><span class=\"line\">workbook = openpyxl.Workbook() </span><br><span class=\"line\"><span class=\"comment\"># 写入文件</span></span><br><span class=\"line\">sheet = workbook.activesheet[<span class=\"string\">'A1'</span>]=<span class=\"string\">'data'</span></span><br><span class=\"line\"><span class=\"comment\"># 保存文件 </span></span><br><span class=\"line\">workbook.save(<span class=\"string\">'test.xlsx'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#或者</span></span><br><span class=\"line\"><span class=\"comment\">#打开文件</span></span><br><span class=\"line\">wb = openpyxl.load_workbook(<span class=\"string\">'test.xlsx'</span>)</span><br><span class=\"line\"><span class=\"comment\">#读取数据</span></span><br><span class=\"line\">ws = wb.active</span><br><span class=\"line\">cols = ws.columns</span><br><span class=\"line\">cols[<span class=\"number\">0</span>][<span class=\"number\">1</span>].value = <span class=\"string\">'data'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-使用win32com操作系统的Excel程序\"><a href=\"#3-使用win32com操作系统的Excel程序\" class=\"headerlink\" title=\"3. 使用win32com操作系统的\bExcel程序\"></a>3. 使用win32com操作系统的\bExcel程序</h3><p>这种方式约束较多，要求Windows + Microsoft Excel，是使用win32com库来操作Excel程序来完成对excel文件的操作，官方的API特别的复杂，要找到自己需要的API还是要费一番功夫的，但是相应的能做的事也就多了，\b你能在Excel程序中做的事，几乎使用win32com都能做，具体可用的可查看官方的<a href=\"https://documentation.devexpress.com/OfficeFileAPI/12078/Spreadsheet-Document-API/Examples/Worksheets\" target=\"_blank\" rel=\"noopener\">文档</a>，\b几乎和vb\b程序差不多，不用看c++的。<br>举\b一些我在项目中用到的例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#打开应用</span></span><br><span class=\"line\">xlApp = win32com.client.Dispatch(<span class=\"string\">'Excel.Application'</span>)</span><br><span class=\"line\"><span class=\"comment\">#打开表格</span></span><br><span class=\"line\">xlBook = xlApp.Workbook.Open(<span class=\"string\">'test.xls'</span>)</span><br><span class=\"line\"><span class=\"comment\">#保存文件</span></span><br><span class=\"line\">xlBook.Save()</span><br><span class=\"line\"><span class=\"comment\">#另存为</span></span><br><span class=\"line\">xlBook.SaveAs(<span class=\"string\">'new.xls'</span>)</span><br><span class=\"line\"><span class=\"comment\">#关闭文件</span></span><br><span class=\"line\">xlBook.Close(SaveChanges=<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">#获得sheet，传入sheet名字</span></span><br><span class=\"line\">sht = xlBook.Worksheets(<span class=\"string\">'Sheet1'</span>)</span><br><span class=\"line\"><span class=\"comment\">#获得sheet2，传入index</span></span><br><span class=\"line\">sht = xlBook.worksheets[index]</span><br><span class=\"line\"><span class=\"comment\">#获得单元格内容</span></span><br><span class=\"line\">data =  sht.Cells(row, col).Value</span><br><span class=\"line\"><span class=\"comment\">#设置单元格内容</span></span><br><span class=\"line\">sht.Cells(row, col).Value = <span class=\"string\">'New Value'</span></span><br><span class=\"line\"><span class=\"comment\">#获得一块</span></span><br><span class=\"line\">myRange = sht.Range(sht.Cells(row1, col1), sht.Cells(row2, col2)).Value</span><br><span class=\"line\"><span class=\"comment\">#选择sheet</span></span><br><span class=\"line\">sht.Activate</span><br><span class=\"line\"><span class=\"comment\">#获得一列</span></span><br><span class=\"line\">sht.Columns(index)</span><br><span class=\"line\"><span class=\"comment\">#删除一列</span></span><br><span class=\"line\">sht.Columns(<span class=\"number\">1</span>).Delete()</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上就是3种常用操作excel的python库，读者可根据自己的情况选择合适的库。</p>\n","site":{"data":{}},"excerpt":"<p>最近需要用到Python去处理excel，目标是根据用户输入的信息，先显示每列的列名以及这一列示例行（取前两行信息），然后根据输入的列号删除对应的列。</p>\n<p>网上搜索了下主要有几种方案：</p>\n<h3 id=\"1-使用xlrd、xlwt、xlutils组合\"><a href=\"#1-使用xlrd、xlwt、xlutils组合\" class=\"headerlink\" title=\"1. 使用xlrd、xlwt、xlutils组合\"></a>1. 使用xlrd、xlwt、xlutils组合</h3><p>这种方案比较常见，而且读取和写入速度较快，但是只能操作2003版本之前的xls文件，处理不了xlsx，所以想要处理2003版本之后的请绕道。</p>\n<blockquote>\n<p>注意！<br>xlutils复制的excel格式上会存在一些问题，我在使用的时候就因为这个原因而\b弃用了，灰底的表格会变成深蓝色底的，\b难以接受。 </p>\n</blockquote>","more":"<p>xlrd用来读取excel内容，xlwt写入excel内容，xlutils封装了一些常用的操作excel的函数供用户使用，一些使用如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#打开excel文件</span></span><br><span class=\"line\">workbook = xlrd.open_workbook(<span class=\"string\">'myexcel.xls'</span>)</span><br><span class=\"line\"><span class=\"comment\">#获取表单</span></span><br><span class=\"line\">worksheet = workbook.sheet_by_index(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">#读取数据</span></span><br><span class=\"line\">data = worksheet.cell_value(<span class=\"number\">0</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">##另一种获取数据，但这种是包含数据类型的，需要内容可通过value获取</span></span><br><span class=\"line\">data2 = worksheet.cell(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">#----xlwt库</span></span><br><span class=\"line\"><span class=\"comment\">#新建excel</span></span><br><span class=\"line\">wb = xlwt.Workbook()</span><br><span class=\"line\"><span class=\"comment\">#添加工作薄</span></span><br><span class=\"line\">sh = wb.add_sheet(<span class=\"string\">'Sheet1'</span>)</span><br><span class=\"line\"><span class=\"comment\">#写入数据</span></span><br><span class=\"line\">sh.write(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"string\">'data'</span>)</span><br><span class=\"line\"><span class=\"comment\">#保存文件</span></span><br><span class=\"line\">wb.save(<span class=\"string\">'myexcel.xls'</span>)</span><br><span class=\"line\"><span class=\"comment\">#----xlutils库</span></span><br><span class=\"line\"><span class=\"comment\">#打开excel文件</span></span><br><span class=\"line\">book = xlrd.open_workbook(<span class=\"string\">'myexcel.xls'</span>)</span><br><span class=\"line\"><span class=\"comment\">#复制一份</span></span><br><span class=\"line\">new_book = xlutils.copy(book)</span><br><span class=\"line\"><span class=\"comment\">#拿到工作薄</span></span><br><span class=\"line\">worksheet = new_book.getsheet(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">#写入数据</span></span><br><span class=\"line\">worksheet.write(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"string\">'new data'</span>)</span><br><span class=\"line\"><span class=\"comment\">#保存</span></span><br><span class=\"line\">new_book.save()</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用openpyxl\"><a href=\"#2-使用openpyxl\" class=\"headerlink\" title=\"2. 使用openpyxl\"></a>2. 使用openpyxl</h3><p>与xlrd、xlwt、xlutils组合不同，openpyxl只支持excel 2003之后的也就是xlsx文件，示例如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> openpyxl</span><br><span class=\"line\"><span class=\"comment\"># 新建文件</span></span><br><span class=\"line\">workbook = openpyxl.Workbook() </span><br><span class=\"line\"><span class=\"comment\"># 写入文件</span></span><br><span class=\"line\">sheet = workbook.activesheet[<span class=\"string\">'A1'</span>]=<span class=\"string\">'data'</span></span><br><span class=\"line\"><span class=\"comment\"># 保存文件 </span></span><br><span class=\"line\">workbook.save(<span class=\"string\">'test.xlsx'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#或者</span></span><br><span class=\"line\"><span class=\"comment\">#打开文件</span></span><br><span class=\"line\">wb = openpyxl.load_workbook(<span class=\"string\">'test.xlsx'</span>)</span><br><span class=\"line\"><span class=\"comment\">#读取数据</span></span><br><span class=\"line\">ws = wb.active</span><br><span class=\"line\">cols = ws.columns</span><br><span class=\"line\">cols[<span class=\"number\">0</span>][<span class=\"number\">1</span>].value = <span class=\"string\">'data'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-使用win32com操作系统的Excel程序\"><a href=\"#3-使用win32com操作系统的Excel程序\" class=\"headerlink\" title=\"3. 使用win32com操作系统的\bExcel程序\"></a>3. 使用win32com操作系统的\bExcel程序</h3><p>这种方式约束较多，要求Windows + Microsoft Excel，是使用win32com库来操作Excel程序来完成对excel文件的操作，官方的API特别的复杂，要找到自己需要的API还是要费一番功夫的，但是相应的能做的事也就多了，\b你能在Excel程序中做的事，几乎使用win32com都能做，具体可用的可查看官方的<a href=\"https://documentation.devexpress.com/OfficeFileAPI/12078/Spreadsheet-Document-API/Examples/Worksheets\" target=\"_blank\" rel=\"noopener\">文档</a>，\b几乎和vb\b程序差不多，不用看c++的。<br>举\b一些我在项目中用到的例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#打开应用</span></span><br><span class=\"line\">xlApp = win32com.client.Dispatch(<span class=\"string\">'Excel.Application'</span>)</span><br><span class=\"line\"><span class=\"comment\">#打开表格</span></span><br><span class=\"line\">xlBook = xlApp.Workbook.Open(<span class=\"string\">'test.xls'</span>)</span><br><span class=\"line\"><span class=\"comment\">#保存文件</span></span><br><span class=\"line\">xlBook.Save()</span><br><span class=\"line\"><span class=\"comment\">#另存为</span></span><br><span class=\"line\">xlBook.SaveAs(<span class=\"string\">'new.xls'</span>)</span><br><span class=\"line\"><span class=\"comment\">#关闭文件</span></span><br><span class=\"line\">xlBook.Close(SaveChanges=<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">#获得sheet，传入sheet名字</span></span><br><span class=\"line\">sht = xlBook.Worksheets(<span class=\"string\">'Sheet1'</span>)</span><br><span class=\"line\"><span class=\"comment\">#获得sheet2，传入index</span></span><br><span class=\"line\">sht = xlBook.worksheets[index]</span><br><span class=\"line\"><span class=\"comment\">#获得单元格内容</span></span><br><span class=\"line\">data =  sht.Cells(row, col).Value</span><br><span class=\"line\"><span class=\"comment\">#设置单元格内容</span></span><br><span class=\"line\">sht.Cells(row, col).Value = <span class=\"string\">'New Value'</span></span><br><span class=\"line\"><span class=\"comment\">#获得一块</span></span><br><span class=\"line\">myRange = sht.Range(sht.Cells(row1, col1), sht.Cells(row2, col2)).Value</span><br><span class=\"line\"><span class=\"comment\">#选择sheet</span></span><br><span class=\"line\">sht.Activate</span><br><span class=\"line\"><span class=\"comment\">#获得一列</span></span><br><span class=\"line\">sht.Columns(index)</span><br><span class=\"line\"><span class=\"comment\">#删除一列</span></span><br><span class=\"line\">sht.Columns(<span class=\"number\">1</span>).Delete()</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上就是3种常用操作excel的python库，读者可根据自己的情况选择合适的库。</p>"},{"title":"Vue 过渡&动画","date":"2018-05-06T12:56:26.000Z","_content":"\n## 单元素/组件的过渡\n\n使用 transition 封装组件：\n\n```html\n<transition name=\"fade\">\n    <p v-if=\"show\">hello</p>\n</transition>\n```\n\n<!-- more -->\n\n### 过渡类名\n\n使用 transition 之后当触发过渡动画时，会添加相应的 class，没有 name 属性时使用 v-，否则使用定义的{$name}-，共有 6 个 class 切换：\n\n1.  v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。\n2.  v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。\n3.  v-enter-to: 2.1.8 版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。\n4.  v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。\n5.  v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。\n6.  v-leave-to: 2.1.8 版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。\n\n具体过程如下：\n\n![vue_transition](/assets/img/vue_transition.png)\n\n### JavaScript 钩子\n\n可以在属性中声明钩子:\n\n```html\n<transition\n  v-on:before-enter=\"beforeEnter\"\n  v-on:enter=\"enter\"\n  v-on:after-enter=\"afterEnter\"\n  v-on:enter-cancelled=\"enterCancelled\"\n\n  v-on:before-leave=\"beforeLeave\"\n  v-on:leave=\"leave\"\n  v-on:after-leave=\"afterLeave\"\n  v-on:leave-cancelled=\"leaveCancelled\"\n>\n  <!-- ... -->\n</transition>\n```\n\n> 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成。\n\n> 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=\"false\"，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。\n\n## 多个元素的过渡\n\n### 过渡 \b 模式\n\n* in-out：新元素先进行过渡，完成之后当前元素过渡离开。\n* out-in：当前元素先进行过渡，完成之后新元素过渡进入。\n\n## 平滑过渡(列表过渡)\n\n使用 \b`<transition-group>`组件，可以使列表过渡起来比较平滑，只需要使用`v-move`即可，具体例子如下：\n\n```html\n<transition-group name=\"flip-list\" tag=\"ul\">\n    <li v-for=\"item in items\" v-bind:key=\"item\">\n      {{ item }}\n    </li>\n</transition-group>\n```\n\n```css\n.flip-list-move {\n  transition: transform 1s;\n}\n```\n\n> 读者有兴趣可以研究一下洗牌算法，可以保证每个数出现的唯一性，shuffle 算法。\n\n这个看起来很神奇，内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。\n\n需要注意的是使用 FLIP 过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中。\n\n---\n\n未完待续\n","source":"_posts/Vue-过渡-动画.md","raw":"---\ntitle: Vue 过渡&动画\ndate: 2018-05-06 20:56:26\ntags:\n    - 前端\n---\n\n## 单元素/组件的过渡\n\n使用 transition 封装组件：\n\n```html\n<transition name=\"fade\">\n    <p v-if=\"show\">hello</p>\n</transition>\n```\n\n<!-- more -->\n\n### 过渡类名\n\n使用 transition 之后当触发过渡动画时，会添加相应的 class，没有 name 属性时使用 v-，否则使用定义的{$name}-，共有 6 个 class 切换：\n\n1.  v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。\n2.  v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。\n3.  v-enter-to: 2.1.8 版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。\n4.  v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。\n5.  v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。\n6.  v-leave-to: 2.1.8 版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。\n\n具体过程如下：\n\n![vue_transition](/assets/img/vue_transition.png)\n\n### JavaScript 钩子\n\n可以在属性中声明钩子:\n\n```html\n<transition\n  v-on:before-enter=\"beforeEnter\"\n  v-on:enter=\"enter\"\n  v-on:after-enter=\"afterEnter\"\n  v-on:enter-cancelled=\"enterCancelled\"\n\n  v-on:before-leave=\"beforeLeave\"\n  v-on:leave=\"leave\"\n  v-on:after-leave=\"afterLeave\"\n  v-on:leave-cancelled=\"leaveCancelled\"\n>\n  <!-- ... -->\n</transition>\n```\n\n> 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成。\n\n> 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=\"false\"，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。\n\n## 多个元素的过渡\n\n### 过渡 \b 模式\n\n* in-out：新元素先进行过渡，完成之后当前元素过渡离开。\n* out-in：当前元素先进行过渡，完成之后新元素过渡进入。\n\n## 平滑过渡(列表过渡)\n\n使用 \b`<transition-group>`组件，可以使列表过渡起来比较平滑，只需要使用`v-move`即可，具体例子如下：\n\n```html\n<transition-group name=\"flip-list\" tag=\"ul\">\n    <li v-for=\"item in items\" v-bind:key=\"item\">\n      {{ item }}\n    </li>\n</transition-group>\n```\n\n```css\n.flip-list-move {\n  transition: transform 1s;\n}\n```\n\n> 读者有兴趣可以研究一下洗牌算法，可以保证每个数出现的唯一性，shuffle 算法。\n\n这个看起来很神奇，内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。\n\n需要注意的是使用 FLIP 过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中。\n\n---\n\n未完待续\n","slug":"Vue-过渡-动画","published":1,"updated":"2018-05-15T12:37:51.740Z","_id":"cjh692bwt0006mzfy0ritrawb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"单元素-组件的过渡\"><a href=\"#单元素-组件的过渡\" class=\"headerlink\" title=\"单元素/组件的过渡\"></a>单元素/组件的过渡</h2><p>使用 transition 封装组件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"过渡类名\"><a href=\"#过渡类名\" class=\"headerlink\" title=\"过渡类名\"></a>过渡类名</h3><p>使用 transition 之后当触发过渡动画时，会添加相应的 class，没有 name 属性时使用 v-，否则使用定义的{$name}-，共有 6 个 class 切换：</p>\n<ol>\n<li>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>\n<li>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>\n<li>v-enter-to: 2.1.8 版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</li>\n<li>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>\n<li>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>\n<li>v-leave-to: 2.1.8 版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</li>\n</ol>\n<p>具体过程如下：</p>\n<p><img src=\"/assets/img/vue_transition.png\" alt=\"vue_transition\"></p>\n<h3 id=\"JavaScript-钩子\"><a href=\"#JavaScript-钩子\" class=\"headerlink\" title=\"JavaScript 钩子\"></a>JavaScript 钩子</h3><p>可以在属性中声明钩子:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:after-enter</span>=<span class=\"string\">\"afterEnter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:enter-cancelled</span>=<span class=\"string\">\"enterCancelled\"</span></span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:before-leave</span>=<span class=\"string\">\"beforeLeave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:after-leave</span>=<span class=\"string\">\"afterLeave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:leave-cancelled</span>=<span class=\"string\">\"leaveCancelled\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成。</p>\n</blockquote>\n<blockquote>\n<p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>\n</blockquote>\n<h2 id=\"多个元素的过渡\"><a href=\"#多个元素的过渡\" class=\"headerlink\" title=\"多个元素的过渡\"></a>多个元素的过渡</h2><h3 id=\"过渡-模式\"><a href=\"#过渡-模式\" class=\"headerlink\" title=\"过渡 \b 模式\"></a>过渡 \b 模式</h3><ul>\n<li>in-out：新元素先进行过渡，完成之后当前元素过渡离开。</li>\n<li>out-in：当前元素先进行过渡，完成之后新元素过渡进入。</li>\n</ul>\n<h2 id=\"平滑过渡-列表过渡\"><a href=\"#平滑过渡-列表过渡\" class=\"headerlink\" title=\"平滑过渡(列表过渡)\"></a>平滑过渡(列表过渡)</h2><p>使用 \b<code>&lt;transition-group&gt;</code>组件，可以使列表过渡起来比较平滑，只需要使用<code>v-move</code>即可，具体例子如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">name</span>=<span class=\"string\">\"flip-list\"</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"ul\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item\"</span>&gt;</span></span><br><span class=\"line\">      &#123;&#123; item &#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.flip-list-move</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: transform <span class=\"number\">1s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>读者有兴趣可以研究一下洗牌算法，可以保证每个数出现的唯一性，shuffle 算法。</p>\n</blockquote>\n<p>这个看起来很神奇，内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。</p>\n<p>需要注意的是使用 FLIP 过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中。</p>\n<hr>\n<p>未完待续</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"单元素-组件的过渡\"><a href=\"#单元素-组件的过渡\" class=\"headerlink\" title=\"单元素/组件的过渡\"></a>单元素/组件的过渡</h2><p>使用 transition 封装组件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"show\"</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>","more":"<h3 id=\"过渡类名\"><a href=\"#过渡类名\" class=\"headerlink\" title=\"过渡类名\"></a>过渡类名</h3><p>使用 transition 之后当触发过渡动画时，会添加相应的 class，没有 name 属性时使用 v-，否则使用定义的{$name}-，共有 6 个 class 切换：</p>\n<ol>\n<li>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>\n<li>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>\n<li>v-enter-to: 2.1.8 版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</li>\n<li>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>\n<li>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>\n<li>v-leave-to: 2.1.8 版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</li>\n</ol>\n<p>具体过程如下：</p>\n<p><img src=\"/assets/img/vue_transition.png\" alt=\"vue_transition\"></p>\n<h3 id=\"JavaScript-钩子\"><a href=\"#JavaScript-钩子\" class=\"headerlink\" title=\"JavaScript 钩子\"></a>JavaScript 钩子</h3><p>可以在属性中声明钩子:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:before-enter</span>=<span class=\"string\">\"beforeEnter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:enter</span>=<span class=\"string\">\"enter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:after-enter</span>=<span class=\"string\">\"afterEnter\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:enter-cancelled</span>=<span class=\"string\">\"enterCancelled\"</span></span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:before-leave</span>=<span class=\"string\">\"beforeLeave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:leave</span>=<span class=\"string\">\"leave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:after-leave</span>=<span class=\"string\">\"afterLeave\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">v-on:leave-cancelled</span>=<span class=\"string\">\"leaveCancelled\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成。</p>\n</blockquote>\n<blockquote>\n<p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>\n</blockquote>\n<h2 id=\"多个元素的过渡\"><a href=\"#多个元素的过渡\" class=\"headerlink\" title=\"多个元素的过渡\"></a>多个元素的过渡</h2><h3 id=\"过渡-模式\"><a href=\"#过渡-模式\" class=\"headerlink\" title=\"过渡 \b 模式\"></a>过渡 \b 模式</h3><ul>\n<li>in-out：新元素先进行过渡，完成之后当前元素过渡离开。</li>\n<li>out-in：当前元素先进行过渡，完成之后新元素过渡进入。</li>\n</ul>\n<h2 id=\"平滑过渡-列表过渡\"><a href=\"#平滑过渡-列表过渡\" class=\"headerlink\" title=\"平滑过渡(列表过渡)\"></a>平滑过渡(列表过渡)</h2><p>使用 \b<code>&lt;transition-group&gt;</code>组件，可以使列表过渡起来比较平滑，只需要使用<code>v-move</code>即可，具体例子如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span> <span class=\"attr\">name</span>=<span class=\"string\">\"flip-list\"</span> <span class=\"attr\">tag</span>=<span class=\"string\">\"ul\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in items\"</span> <span class=\"attr\">v-bind:key</span>=<span class=\"string\">\"item\"</span>&gt;</span></span><br><span class=\"line\">      &#123;&#123; item &#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.flip-list-move</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: transform <span class=\"number\">1s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>读者有兴趣可以研究一下洗牌算法，可以保证每个数出现的唯一性，shuffle 算法。</p>\n</blockquote>\n<p>这个看起来很神奇，内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。</p>\n<p>需要注意的是使用 FLIP 过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中。</p>\n<hr>\n<p>未完待续</p>"},{"title":"Vue 基础的一些注意事项","date":"2018-04-17T07:47:16.000Z","_content":"\n最近准备学习一波 Vue，因为有 React 的基础，所以学起来倒也不是很吃力。下面是一些在学习中遇到的可能需要注意的地方。\n\n## 模板语法\n\n### 插值\n\n> 1.  绝对不要使用用户的输入作为插值，可能造成 XSS 攻击。\n> 2.  每个绑定只能包含单个表达式，下面表达式都不会生效。\n\n<!-- more -->\n\n```html\n<!-- 这是语句，不是表达式 -->\n{{ var a = 1 }}\n\n<!-- 流控制也不会生效，请使用三元表达式 -->\n{{ if (ok) { return message } }}\n```\n\n### 指令\n\n.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault():\n\n```html\n<form v-on:submit.prevent=\"onSubmit\">...</form>\n```\n\n## 计算属性和侦听器\n\n### 计算属性\n\n默认只有 getter，但是也可以有 setter\n\n### 侦听器\n\n何时使用侦听器（watch）:当需要在数据变化时执行异步或开销较大的操作。\n\n## 条件渲染\n\n### key\n\nVue\b 默认情况下是会复用元素的，例如切换用户名或邮箱登录，如果两者都有 input 元素，那么在切换的时候 input 不会被替换掉，只会更改 placeholder 之类的属性。\n\n如果添加了唯一的 key 值，Vue 将不会再复用元素，\b 使用 key\b 来判断是否元素变更。\n\n### v-show\n\n注意，v-show 不支持 <template\\> 元素，也不支持 v-else，如下：\n\n```html\n<template v-show=\"!show\">\n    <!-- will show 'template-show' -->\n    <div>template-show</div>\n</template>\n\n<div v-show=\"!show\">\n    if\n</div>\n<!-- can't use v-else after v-show -->\n```\n\n### v-for 与 v-if\n\nv-for 的优先级更高，所以可以对每一项进行 if 判断是否显示。\n\n## 数组更新检测\n\n直接改变数组内容的称为变异方法，如 push、pop、shift、unshift、splice、sort 等，可以响应更新；而直接生成新数组的方法如 slice、concat、filter 等则需要对 data 进行赋值，如\n\n```javascript\nexample1.items = example1.items.filter(function(item) {\n  return item.message.match(/Foo/)\n})\n```\n\n### 不能检测更新\n\n利用索引更改，arr[index] = newValue，或者改变数组长度，arr.length = newLength，可以用下面两种方式实现更新：\n\n```javascript\n// Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n// Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n//change length\nvm.items.splice(newLength)\n```\n\n## 事件处理\n\n@keyup.ctrl 控制时，仅仅按下 ctrl 并弹起是无用的，其他键必须同时按下才有效。\n\n## 表单输入绑定\n\n### 基础用法\n\nv-model 绑定时，如果是基于输入法（中文、日文等）不会实时更新，只是输入结束后才会更新。\n\n## 组件\n\n### DOM 模板 \b 解析注意事项\n\n> 当使用 DOM 作为模板时 (例如，使用 el 选项来把 Vue 实例挂载到一个已有内容的元素上)，你会受到 HTML 本身的一些限制，因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容。尤其要注意，像 <ul\\>、<ol\\>、<table\\>、<select\\> 这样的元素里允许包含的元素有限制，而另一些像 <option\\> 这样的元素只能出现在某些特定元素的内部。在自定义组件中使用这些受限制的元素时会导致一些问题，例如：\n\n```html\n<table>\n  <my-row>...</my-row>\n</table>\n```\n\n自定义组件 <my-row> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的 is 特性：\n\n```html\n<table>\n  <tr is=\"my-row\"></tr>\n</table>\n```\n\n但是在.vue 文件或者使用字符串模板（template: '<div\\>123</div\\>'）则不会有这个问题。\n\n### Prop\n\nclass 和 style 会合并属性，父组件值和组件内的值进行合并\n\n### 给组件绑定原生事件\n\n```html\n<my-component v-on:click.native=\"doTheThing\"></my-component>\n```\n\n### .sync\b 修饰符\n\n2.0 移除但是 2.3 版本又加了回来，但是变成了编译的语法糖，会自动添加 v-on 绑定，如下代码：\n\n```html\n<comp :foo.sync=\"bar\"></comp>\n```\n\n会被扩展为：\n\n```html\n<comp :foo=\"bar\" @update:foo=\"val => bar = val\"></comp>\n```\n\n当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：\n\n```js\nthis.$emit('update:foo', newValue)\n```\n\n### 非父子组件之间的通信\n\n```js\nvar bus = new Vue()\n\n// 触发组件 A 中的事件\nbus.$emit('id-selected', 1)\n\n// 在组件 B 创建的钩子中监听事件\nbus.$on('id-selected', function(id) {\n  // ...\n})\n```\n\n### 使用插槽分发内容\n\n> 除非子组件模板包含至少一个 **<slot\\>** 插口，否则父组件的内容将会被**丢弃**。\n\n```html\n<div>\n  <h2>我是子组件的标题</h2>\n  <slot>\n    只有在没有要分发的内容时才会显示。\n  </slot>\n</div>\n```\n\n### 作用域插槽\n\n> **<slot\\>** 元素可以用一个特殊的特性 name 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。\n\n> 在 2.5.0+，**slot-scope** 能被用在任意元素或组件中而不再局限于 **<template\\>**。\n\n### 解构\n\nslot-scope 支持解构，如下：\n\n```html\n<child>\n  <span slot-scope=\"{ text }\">{{ text }}</span>\n</child>\n```\n\n其中 { text } 将子组件传递来的值进行解构，比如子组件有值 obj: {text: 'test message'}。\n\n### 动态组件\n\n> 通过使用保留的 <component> 元素，并对其 is 特性进行动态绑定，你可以在同一个挂载点动态切换多个组件：\n\n```js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    currentView: 'home' //也可以是对象组件\n  },\n  components: {\n    home: {\n      /* ... */\n    },\n    posts: {\n      /* ... */\n    },\n    archive: {\n      /* ... */\n    }\n  }\n})\n```\n\n```html\n<component v-bind:is=\"currentView\">\n  <!-- 组件在 vm.currentview 变化时改变！ -->\n</component>\n```\n\n动态组件需要缓存的时候可以使用 keep-alive，失活的组件会被缓存，避免重复渲染：\n\n```html\n<!-- 失活的组件将会被缓存！-->\n<keep-alive>\n  <component v-bind:is=\"currentTabComponent\"></component>\n</keep-alive>\n```\n\n### 组件间的循环引用\n\n常见的情况是文件系统，文件夹(folder)包含的内容(content)可能包含文件夹(folder)，这样就形成了循环引用，当使用 Vue.component 将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾。然而，如果你使用诸如 webpack 或者 Browserify 之类的模块化管理工具来 require/import 组件的话，就会报错了：\n\n```\nFailed to mount component: template or render function not defined.\n```\n\n我们可以选择在文件夹(folder)组件中声明在 beforeCreate 时才注册组件：\n\n```js\nbeforeCreate: function () {\n  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default\n}\n```\n\n### v-once\n\n使用 v-once 指令使得模板只会渲染一遍而不会监听数据改变。\n\n## 处理边界情况\n\n### 依赖注入\n\n> provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 <google-map> 内部的 getMap 方法：\n\n```js\nprovide: function () {\n  return {\n    getMap: this.getMap\n  }\n}\n```\n\n在任何后代都能使用getMap方法，只要在后代组件里声明注入：\n\n```js\ninject: ['getMap']\n```\n\n### 内联模板\n\n```html\n<button-message v-on:message=\"handleMessage\" inline-template>\n      <p>slot</p>\n</button-message>\n```\n\n最后渲染的会是slot，而不是button-message定义的模板内容。\n\n","source":"_posts/Vue基础的一些注意事项.md","raw":"---\ntitle: Vue 基础的一些注意事项\ndate: 2018-04-17 15:47:16\ntags:\n    - 前端\n---\n\n最近准备学习一波 Vue，因为有 React 的基础，所以学起来倒也不是很吃力。下面是一些在学习中遇到的可能需要注意的地方。\n\n## 模板语法\n\n### 插值\n\n> 1.  绝对不要使用用户的输入作为插值，可能造成 XSS 攻击。\n> 2.  每个绑定只能包含单个表达式，下面表达式都不会生效。\n\n<!-- more -->\n\n```html\n<!-- 这是语句，不是表达式 -->\n{{ var a = 1 }}\n\n<!-- 流控制也不会生效，请使用三元表达式 -->\n{{ if (ok) { return message } }}\n```\n\n### 指令\n\n.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault():\n\n```html\n<form v-on:submit.prevent=\"onSubmit\">...</form>\n```\n\n## 计算属性和侦听器\n\n### 计算属性\n\n默认只有 getter，但是也可以有 setter\n\n### 侦听器\n\n何时使用侦听器（watch）:当需要在数据变化时执行异步或开销较大的操作。\n\n## 条件渲染\n\n### key\n\nVue\b 默认情况下是会复用元素的，例如切换用户名或邮箱登录，如果两者都有 input 元素，那么在切换的时候 input 不会被替换掉，只会更改 placeholder 之类的属性。\n\n如果添加了唯一的 key 值，Vue 将不会再复用元素，\b 使用 key\b 来判断是否元素变更。\n\n### v-show\n\n注意，v-show 不支持 <template\\> 元素，也不支持 v-else，如下：\n\n```html\n<template v-show=\"!show\">\n    <!-- will show 'template-show' -->\n    <div>template-show</div>\n</template>\n\n<div v-show=\"!show\">\n    if\n</div>\n<!-- can't use v-else after v-show -->\n```\n\n### v-for 与 v-if\n\nv-for 的优先级更高，所以可以对每一项进行 if 判断是否显示。\n\n## 数组更新检测\n\n直接改变数组内容的称为变异方法，如 push、pop、shift、unshift、splice、sort 等，可以响应更新；而直接生成新数组的方法如 slice、concat、filter 等则需要对 data 进行赋值，如\n\n```javascript\nexample1.items = example1.items.filter(function(item) {\n  return item.message.match(/Foo/)\n})\n```\n\n### 不能检测更新\n\n利用索引更改，arr[index] = newValue，或者改变数组长度，arr.length = newLength，可以用下面两种方式实现更新：\n\n```javascript\n// Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n// Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n//change length\nvm.items.splice(newLength)\n```\n\n## 事件处理\n\n@keyup.ctrl 控制时，仅仅按下 ctrl 并弹起是无用的，其他键必须同时按下才有效。\n\n## 表单输入绑定\n\n### 基础用法\n\nv-model 绑定时，如果是基于输入法（中文、日文等）不会实时更新，只是输入结束后才会更新。\n\n## 组件\n\n### DOM 模板 \b 解析注意事项\n\n> 当使用 DOM 作为模板时 (例如，使用 el 选项来把 Vue 实例挂载到一个已有内容的元素上)，你会受到 HTML 本身的一些限制，因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容。尤其要注意，像 <ul\\>、<ol\\>、<table\\>、<select\\> 这样的元素里允许包含的元素有限制，而另一些像 <option\\> 这样的元素只能出现在某些特定元素的内部。在自定义组件中使用这些受限制的元素时会导致一些问题，例如：\n\n```html\n<table>\n  <my-row>...</my-row>\n</table>\n```\n\n自定义组件 <my-row> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的 is 特性：\n\n```html\n<table>\n  <tr is=\"my-row\"></tr>\n</table>\n```\n\n但是在.vue 文件或者使用字符串模板（template: '<div\\>123</div\\>'）则不会有这个问题。\n\n### Prop\n\nclass 和 style 会合并属性，父组件值和组件内的值进行合并\n\n### 给组件绑定原生事件\n\n```html\n<my-component v-on:click.native=\"doTheThing\"></my-component>\n```\n\n### .sync\b 修饰符\n\n2.0 移除但是 2.3 版本又加了回来，但是变成了编译的语法糖，会自动添加 v-on 绑定，如下代码：\n\n```html\n<comp :foo.sync=\"bar\"></comp>\n```\n\n会被扩展为：\n\n```html\n<comp :foo=\"bar\" @update:foo=\"val => bar = val\"></comp>\n```\n\n当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：\n\n```js\nthis.$emit('update:foo', newValue)\n```\n\n### 非父子组件之间的通信\n\n```js\nvar bus = new Vue()\n\n// 触发组件 A 中的事件\nbus.$emit('id-selected', 1)\n\n// 在组件 B 创建的钩子中监听事件\nbus.$on('id-selected', function(id) {\n  // ...\n})\n```\n\n### 使用插槽分发内容\n\n> 除非子组件模板包含至少一个 **<slot\\>** 插口，否则父组件的内容将会被**丢弃**。\n\n```html\n<div>\n  <h2>我是子组件的标题</h2>\n  <slot>\n    只有在没有要分发的内容时才会显示。\n  </slot>\n</div>\n```\n\n### 作用域插槽\n\n> **<slot\\>** 元素可以用一个特殊的特性 name 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。\n\n> 在 2.5.0+，**slot-scope** 能被用在任意元素或组件中而不再局限于 **<template\\>**。\n\n### 解构\n\nslot-scope 支持解构，如下：\n\n```html\n<child>\n  <span slot-scope=\"{ text }\">{{ text }}</span>\n</child>\n```\n\n其中 { text } 将子组件传递来的值进行解构，比如子组件有值 obj: {text: 'test message'}。\n\n### 动态组件\n\n> 通过使用保留的 <component> 元素，并对其 is 特性进行动态绑定，你可以在同一个挂载点动态切换多个组件：\n\n```js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    currentView: 'home' //也可以是对象组件\n  },\n  components: {\n    home: {\n      /* ... */\n    },\n    posts: {\n      /* ... */\n    },\n    archive: {\n      /* ... */\n    }\n  }\n})\n```\n\n```html\n<component v-bind:is=\"currentView\">\n  <!-- 组件在 vm.currentview 变化时改变！ -->\n</component>\n```\n\n动态组件需要缓存的时候可以使用 keep-alive，失活的组件会被缓存，避免重复渲染：\n\n```html\n<!-- 失活的组件将会被缓存！-->\n<keep-alive>\n  <component v-bind:is=\"currentTabComponent\"></component>\n</keep-alive>\n```\n\n### 组件间的循环引用\n\n常见的情况是文件系统，文件夹(folder)包含的内容(content)可能包含文件夹(folder)，这样就形成了循环引用，当使用 Vue.component 将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾。然而，如果你使用诸如 webpack 或者 Browserify 之类的模块化管理工具来 require/import 组件的话，就会报错了：\n\n```\nFailed to mount component: template or render function not defined.\n```\n\n我们可以选择在文件夹(folder)组件中声明在 beforeCreate 时才注册组件：\n\n```js\nbeforeCreate: function () {\n  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default\n}\n```\n\n### v-once\n\n使用 v-once 指令使得模板只会渲染一遍而不会监听数据改变。\n\n## 处理边界情况\n\n### 依赖注入\n\n> provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 <google-map> 内部的 getMap 方法：\n\n```js\nprovide: function () {\n  return {\n    getMap: this.getMap\n  }\n}\n```\n\n在任何后代都能使用getMap方法，只要在后代组件里声明注入：\n\n```js\ninject: ['getMap']\n```\n\n### 内联模板\n\n```html\n<button-message v-on:message=\"handleMessage\" inline-template>\n      <p>slot</p>\n</button-message>\n```\n\n最后渲染的会是slot，而不是button-message定义的模板内容。\n\n","slug":"Vue基础的一些注意事项","published":1,"updated":"2018-05-06T12:49:35.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh692bwu0007mzfyfsrgsha6","content":"<p>最近准备学习一波 Vue，因为有 React 的基础，所以学起来倒也不是很吃力。下面是一些在学习中遇到的可能需要注意的地方。</p>\n<h2 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h2><h3 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h3><blockquote>\n<ol>\n<li>绝对不要使用用户的输入作为插值，可能造成 XSS 攻击。</li>\n<li>每个绑定只能包含单个表达式，下面表达式都不会生效。</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class=\"line\">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class=\"line\">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault():</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"计算属性和侦听器\"><a href=\"#计算属性和侦听器\" class=\"headerlink\" title=\"计算属性和侦听器\"></a>计算属性和侦听器</h2><h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><p>默认只有 getter，但是也可以有 setter</p>\n<h3 id=\"侦听器\"><a href=\"#侦听器\" class=\"headerlink\" title=\"侦听器\"></a>侦听器</h3><p>何时使用侦听器（watch）:当需要在数据变化时执行异步或开销较大的操作。</p>\n<h2 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h2><h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><p>Vue\b 默认情况下是会复用元素的，例如切换用户名或邮箱登录，如果两者都有 input 元素，那么在切换的时候 input 不会被替换掉，只会更改 placeholder 之类的属性。</p>\n<p>如果添加了唯一的 key 值，Vue 将不会再复用元素，\b 使用 key\b 来判断是否元素变更。</p>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><p>注意，v-show 不支持 &lt;template> 元素，也不支持 v-else，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"!show\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- will show 'template-show' --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>template-show<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"!show\"</span>&gt;</span></span><br><span class=\"line\">    if</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- can't use v-else after v-show --&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"v-for-与-v-if\"><a href=\"#v-for-与-v-if\" class=\"headerlink\" title=\"v-for 与 v-if\"></a>v-for 与 v-if</h3><p>v-for 的优先级更高，所以可以对每一项进行 if 判断是否显示。</p>\n<h2 id=\"数组更新检测\"><a href=\"#数组更新检测\" class=\"headerlink\" title=\"数组更新检测\"></a>数组更新检测</h2><p>直接改变数组内容的称为变异方法，如 push、pop、shift、unshift、splice、sort 等，可以响应更新；而直接生成新数组的方法如 slice、concat、filter 等则需要对 data 进行赋值，如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example1.items = example1.items.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item.message.match(<span class=\"regexp\">/Foo/</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"不能检测更新\"><a href=\"#不能检测更新\" class=\"headerlink\" title=\"不能检测更新\"></a>不能检测更新</h3><p>利用索引更改，arr[index] = newValue，或者改变数组长度，arr.length = newLength，可以用下面两种方式实现更新：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vue.set</span></span><br><span class=\"line\">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class=\"line\"><span class=\"comment\">// Array.prototype.splice</span></span><br><span class=\"line\">vm.items.splice(indexOfItem, <span class=\"number\">1</span>, newValue)</span><br><span class=\"line\"><span class=\"comment\">//change length</span></span><br><span class=\"line\">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>\n<h2 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h2><p>@keyup.ctrl 控制时，仅仅按下 ctrl 并弹起是无用的，其他键必须同时按下才有效。</p>\n<h2 id=\"表单输入绑定\"><a href=\"#表单输入绑定\" class=\"headerlink\" title=\"表单输入绑定\"></a>表单输入绑定</h2><h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>v-model 绑定时，如果是基于输入法（中文、日文等）不会实时更新，只是输入结束后才会更新。</p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><h3 id=\"DOM-模板-解析注意事项\"><a href=\"#DOM-模板-解析注意事项\" class=\"headerlink\" title=\"DOM 模板 \b 解析注意事项\"></a>DOM 模板 \b 解析注意事项</h3><blockquote>\n<p>当使用 DOM 作为模板时 (例如，使用 el 选项来把 Vue 实例挂载到一个已有内容的元素上)，你会受到 HTML 本身的一些限制，因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容。尤其要注意，像 &lt;ul>、&lt;ol>、&lt;table>、&lt;select> 这样的元素里允许包含的元素有限制，而另一些像 &lt;option> 这样的元素只能出现在某些特定元素的内部。在自定义组件中使用这些受限制的元素时会导致一些问题，例如：</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-row</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">my-row</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>自定义组件 <my-row> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的 is 特性：</my-row></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tr</span> <span class=\"attr\">is</span>=<span class=\"string\">\"my-row\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是在.vue 文件或者使用字符串模板（template: ‘&lt;div>123&lt;/div>‘）则不会有这个问题。</p>\n<h3 id=\"Prop\"><a href=\"#Prop\" class=\"headerlink\" title=\"Prop\"></a>Prop</h3><p>class 和 style 会合并属性，父组件值和组件内的值进行合并</p>\n<h3 id=\"给组件绑定原生事件\"><a href=\"#给组件绑定原生事件\" class=\"headerlink\" title=\"给组件绑定原生事件\"></a>给组件绑定原生事件</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-on:click.native</span>=<span class=\"string\">\"doTheThing\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sync-修饰符\"><a href=\"#sync-修饰符\" class=\"headerlink\" title=\".sync\b 修饰符\"></a>.sync\b 修饰符</h3><p>2.0 移除但是 2.3 版本又加了回来，但是变成了编译的语法糖，会自动添加 v-on 绑定，如下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">:foo.sync</span>=<span class=\"string\">\"bar\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>会被扩展为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">:foo</span>=<span class=\"string\">\"bar\"</span> @<span class=\"attr\">update:foo</span>=<span class=\"string\">\"val =&gt; bar = val\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.$emit(<span class=\"string\">'update:foo'</span>, newValue)</span><br></pre></td></tr></table></figure>\n<h3 id=\"非父子组件之间的通信\"><a href=\"#非父子组件之间的通信\" class=\"headerlink\" title=\"非父子组件之间的通信\"></a>非父子组件之间的通信</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bus = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发组件 A 中的事件</span></span><br><span class=\"line\">bus.$emit(<span class=\"string\">'id-selected'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在组件 B 创建的钩子中监听事件</span></span><br><span class=\"line\">bus.$on(<span class=\"string\">'id-selected'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用插槽分发内容\"><a href=\"#使用插槽分发内容\" class=\"headerlink\" title=\"使用插槽分发内容\"></a>使用插槽分发内容</h3><blockquote>\n<p>除非子组件模板包含至少一个 <strong>&lt;slot></strong> 插口，否则父组件的内容将会被<strong>丢弃</strong>。</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是子组件的标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    只有在没有要分发的内容时才会显示。</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h3><blockquote>\n<p><strong>&lt;slot></strong> 元素可以用一个特殊的特性 name 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。</p>\n</blockquote>\n<blockquote>\n<p>在 2.5.0+，<strong>slot-scope</strong> 能被用在任意元素或组件中而不再局限于 <strong>&lt;template></strong>。</p>\n</blockquote>\n<h3 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h3><p>slot-scope 支持解构，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">slot-scope</span>=<span class=\"string\">\"&#123; text &#125;\"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其中 { text } 将子组件传递来的值进行解构，比如子组件有值 obj: {text: ‘test message’}。</p>\n<h3 id=\"动态组件\"><a href=\"#动态组件\" class=\"headerlink\" title=\"动态组件\"></a>动态组件</h3><blockquote>\n<p>通过使用保留的 <component> 元素，并对其 is 特性进行动态绑定，你可以在同一个挂载点动态切换多个组件：</component></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#example'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    currentView: <span class=\"string\">'home'</span> <span class=\"comment\">//也可以是对象组件</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    home: &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    posts: &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    archive: &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"currentView\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>动态组件需要缓存的时候可以使用 keep-alive，失活的组件会被缓存，避免重复渲染：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"currentTabComponent\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"组件间的循环引用\"><a href=\"#组件间的循环引用\" class=\"headerlink\" title=\"组件间的循环引用\"></a>组件间的循环引用</h3><p>常见的情况是文件系统，文件夹(folder)包含的内容(content)可能包含文件夹(folder)，这样就形成了循环引用，当使用 Vue.component 将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾。然而，如果你使用诸如 webpack 或者 Browserify 之类的模块化管理工具来 require/import 组件的话，就会报错了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failed to mount component: template or render function not defined.</span><br></pre></td></tr></table></figure>\n<p>我们可以选择在文件夹(folder)组件中声明在 beforeCreate 时才注册组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$options.components.TreeFolderContents = <span class=\"built_in\">require</span>(<span class=\"string\">'./tree-folder-contents.vue'</span>).default</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h3><p>使用 v-once 指令使得模板只会渲染一遍而不会监听数据改变。</p>\n<h2 id=\"处理边界情况\"><a href=\"#处理边界情况\" class=\"headerlink\" title=\"处理边界情况\"></a>处理边界情况</h2><h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><blockquote>\n<p>provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 <google-map> 内部的 getMap 方法：</google-map></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">provide: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getMap: <span class=\"keyword\">this</span>.getMap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在任何后代都能使用getMap方法，只要在后代组件里声明注入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inject: [<span class=\"string\">'getMap'</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"内联模板\"><a href=\"#内联模板\" class=\"headerlink\" title=\"内联模板\"></a>内联模板</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button-message</span> <span class=\"attr\">v-on:message</span>=<span class=\"string\">\"handleMessage\"</span> <span class=\"attr\">inline-template</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>slot<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button-message</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>最后渲染的会是slot，而不是button-message定义的模板内容。</p>\n","site":{"data":{}},"excerpt":"<p>最近准备学习一波 Vue，因为有 React 的基础，所以学起来倒也不是很吃力。下面是一些在学习中遇到的可能需要注意的地方。</p>\n<h2 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h2><h3 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h3><blockquote>\n<ol>\n<li>绝对不要使用用户的输入作为插值，可能造成 XSS 攻击。</li>\n<li>每个绑定只能包含单个表达式，下面表达式都不会生效。</li>\n</ol>\n</blockquote>","more":"<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class=\"line\">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class=\"line\">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault():</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"计算属性和侦听器\"><a href=\"#计算属性和侦听器\" class=\"headerlink\" title=\"计算属性和侦听器\"></a>计算属性和侦听器</h2><h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><p>默认只有 getter，但是也可以有 setter</p>\n<h3 id=\"侦听器\"><a href=\"#侦听器\" class=\"headerlink\" title=\"侦听器\"></a>侦听器</h3><p>何时使用侦听器（watch）:当需要在数据变化时执行异步或开销较大的操作。</p>\n<h2 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h2><h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><p>Vue\b 默认情况下是会复用元素的，例如切换用户名或邮箱登录，如果两者都有 input 元素，那么在切换的时候 input 不会被替换掉，只会更改 placeholder 之类的属性。</p>\n<p>如果添加了唯一的 key 值，Vue 将不会再复用元素，\b 使用 key\b 来判断是否元素变更。</p>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><p>注意，v-show 不支持 &lt;template> 元素，也不支持 v-else，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"!show\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- will show 'template-show' --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>template-show<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-show</span>=<span class=\"string\">\"!show\"</span>&gt;</span></span><br><span class=\"line\">    if</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- can't use v-else after v-show --&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"v-for-与-v-if\"><a href=\"#v-for-与-v-if\" class=\"headerlink\" title=\"v-for 与 v-if\"></a>v-for 与 v-if</h3><p>v-for 的优先级更高，所以可以对每一项进行 if 判断是否显示。</p>\n<h2 id=\"数组更新检测\"><a href=\"#数组更新检测\" class=\"headerlink\" title=\"数组更新检测\"></a>数组更新检测</h2><p>直接改变数组内容的称为变异方法，如 push、pop、shift、unshift、splice、sort 等，可以响应更新；而直接生成新数组的方法如 slice、concat、filter 等则需要对 data 进行赋值，如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">example1.items = example1.items.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item.message.match(<span class=\"regexp\">/Foo/</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"不能检测更新\"><a href=\"#不能检测更新\" class=\"headerlink\" title=\"不能检测更新\"></a>不能检测更新</h3><p>利用索引更改，arr[index] = newValue，或者改变数组长度，arr.length = newLength，可以用下面两种方式实现更新：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vue.set</span></span><br><span class=\"line\">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class=\"line\"><span class=\"comment\">// Array.prototype.splice</span></span><br><span class=\"line\">vm.items.splice(indexOfItem, <span class=\"number\">1</span>, newValue)</span><br><span class=\"line\"><span class=\"comment\">//change length</span></span><br><span class=\"line\">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>\n<h2 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h2><p>@keyup.ctrl 控制时，仅仅按下 ctrl 并弹起是无用的，其他键必须同时按下才有效。</p>\n<h2 id=\"表单输入绑定\"><a href=\"#表单输入绑定\" class=\"headerlink\" title=\"表单输入绑定\"></a>表单输入绑定</h2><h3 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h3><p>v-model 绑定时，如果是基于输入法（中文、日文等）不会实时更新，只是输入结束后才会更新。</p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><h3 id=\"DOM-模板-解析注意事项\"><a href=\"#DOM-模板-解析注意事项\" class=\"headerlink\" title=\"DOM 模板 \b 解析注意事项\"></a>DOM 模板 \b 解析注意事项</h3><blockquote>\n<p>当使用 DOM 作为模板时 (例如，使用 el 选项来把 Vue 实例挂载到一个已有内容的元素上)，你会受到 HTML 本身的一些限制，因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容。尤其要注意，像 &lt;ul>、&lt;ol>、&lt;table>、&lt;select> 这样的元素里允许包含的元素有限制，而另一些像 &lt;option> 这样的元素只能出现在某些特定元素的内部。在自定义组件中使用这些受限制的元素时会导致一些问题，例如：</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-row</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">my-row</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>自定义组件 <my-row> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的 is 特性：</my-row></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tr</span> <span class=\"attr\">is</span>=<span class=\"string\">\"my-row\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是在.vue 文件或者使用字符串模板（template: ‘&lt;div>123&lt;/div>‘）则不会有这个问题。</p>\n<h3 id=\"Prop\"><a href=\"#Prop\" class=\"headerlink\" title=\"Prop\"></a>Prop</h3><p>class 和 style 会合并属性，父组件值和组件内的值进行合并</p>\n<h3 id=\"给组件绑定原生事件\"><a href=\"#给组件绑定原生事件\" class=\"headerlink\" title=\"给组件绑定原生事件\"></a>给组件绑定原生事件</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span> <span class=\"attr\">v-on:click.native</span>=<span class=\"string\">\"doTheThing\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sync-修饰符\"><a href=\"#sync-修饰符\" class=\"headerlink\" title=\".sync\b 修饰符\"></a>.sync\b 修饰符</h3><p>2.0 移除但是 2.3 版本又加了回来，但是变成了编译的语法糖，会自动添加 v-on 绑定，如下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">:foo.sync</span>=<span class=\"string\">\"bar\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>会被扩展为：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">:foo</span>=<span class=\"string\">\"bar\"</span> @<span class=\"attr\">update:foo</span>=<span class=\"string\">\"val =&gt; bar = val\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.$emit(<span class=\"string\">'update:foo'</span>, newValue)</span><br></pre></td></tr></table></figure>\n<h3 id=\"非父子组件之间的通信\"><a href=\"#非父子组件之间的通信\" class=\"headerlink\" title=\"非父子组件之间的通信\"></a>非父子组件之间的通信</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bus = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发组件 A 中的事件</span></span><br><span class=\"line\">bus.$emit(<span class=\"string\">'id-selected'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在组件 B 创建的钩子中监听事件</span></span><br><span class=\"line\">bus.$on(<span class=\"string\">'id-selected'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用插槽分发内容\"><a href=\"#使用插槽分发内容\" class=\"headerlink\" title=\"使用插槽分发内容\"></a>使用插槽分发内容</h3><blockquote>\n<p>除非子组件模板包含至少一个 <strong>&lt;slot></strong> 插口，否则父组件的内容将会被<strong>丢弃</strong>。</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是子组件的标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    只有在没有要分发的内容时才会显示。</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h3><blockquote>\n<p><strong>&lt;slot></strong> 元素可以用一个特殊的特性 name 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。</p>\n</blockquote>\n<blockquote>\n<p>在 2.5.0+，<strong>slot-scope</strong> 能被用在任意元素或组件中而不再局限于 <strong>&lt;template></strong>。</p>\n</blockquote>\n<h3 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h3><p>slot-scope 支持解构，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">slot-scope</span>=<span class=\"string\">\"&#123; text &#125;\"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其中 { text } 将子组件传递来的值进行解构，比如子组件有值 obj: {text: ‘test message’}。</p>\n<h3 id=\"动态组件\"><a href=\"#动态组件\" class=\"headerlink\" title=\"动态组件\"></a>动态组件</h3><blockquote>\n<p>通过使用保留的 <component> 元素，并对其 is 特性进行动态绑定，你可以在同一个挂载点动态切换多个组件：</component></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#example'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    currentView: <span class=\"string\">'home'</span> <span class=\"comment\">//也可以是对象组件</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    home: &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    posts: &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    archive: &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"currentView\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>动态组件需要缓存的时候可以使用 keep-alive，失活的组件会被缓存，避免重复渲染：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">v-bind:is</span>=<span class=\"string\">\"currentTabComponent\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">component</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"组件间的循环引用\"><a href=\"#组件间的循环引用\" class=\"headerlink\" title=\"组件间的循环引用\"></a>组件间的循环引用</h3><p>常见的情况是文件系统，文件夹(folder)包含的内容(content)可能包含文件夹(folder)，这样就形成了循环引用，当使用 Vue.component 将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾。然而，如果你使用诸如 webpack 或者 Browserify 之类的模块化管理工具来 require/import 组件的话，就会报错了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failed to mount component: template or render function not defined.</span><br></pre></td></tr></table></figure>\n<p>我们可以选择在文件夹(folder)组件中声明在 beforeCreate 时才注册组件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.$options.components.TreeFolderContents = <span class=\"built_in\">require</span>(<span class=\"string\">'./tree-folder-contents.vue'</span>).default</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h3><p>使用 v-once 指令使得模板只会渲染一遍而不会监听数据改变。</p>\n<h2 id=\"处理边界情况\"><a href=\"#处理边界情况\" class=\"headerlink\" title=\"处理边界情况\"></a>处理边界情况</h2><h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><blockquote>\n<p>provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 <google-map> 内部的 getMap 方法：</google-map></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">provide: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getMap: <span class=\"keyword\">this</span>.getMap</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在任何后代都能使用getMap方法，只要在后代组件里声明注入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inject: [<span class=\"string\">'getMap'</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"内联模板\"><a href=\"#内联模板\" class=\"headerlink\" title=\"内联模板\"></a>内联模板</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button-message</span> <span class=\"attr\">v-on:message</span>=<span class=\"string\">\"handleMessage\"</span> <span class=\"attr\">inline-template</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>slot<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button-message</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>最后渲染的会是slot，而不是button-message定义的模板内容。</p>"},{"title":"开始我的instagrame","date":"2016-05-20T07:09:39.000Z","_content":"## 一次偶然的机会，我认识了instagrame\n一天，一个偶然，我逛了下[litten](http://litten.github.io/ \"litten的博客\")的博客，发现了他把自己的照片分享在了博客上，于是我便很好奇博主是用了什么方法分享的。于是我查看了博主搭建博客的过程，了解到他是分享了在instagrame上的照片，这就是我第一次认识instagrame。\n\n## 开始了解instagrame\n秉着好学的心态，我也想在自己的博客上搭建一个这样分享照片的平台，就这样我开始了我的instagrame之旅。\n<!-- more -->\n### 百度百科的介绍：\n>Instagram是一款最初运行在iOS平台上的移动应用，以一种快速、美妙和有趣的方式将你随时抓拍下的图片分享彼此，安卓版Instagram于2012年4月3日起登陆Android应用商店Google Play。2012年4月10号，Facebook宣布以10亿美元收购Instagram。2012年10月25号，Facebook以总值7.15亿美元收购Instagram。2012年12月，Facebook旗下的图片共享服务Instagram因其使用图片共享服务的新条款而在互联网上引起轩然大波，Instagram对此进行了澄清，称不会在广告中使用或销售用户的照片，从而打消了用户的顾虑。北京时间2013年10月22日，诺基亚宣布instagram将会入驻Windows Phone市场，11月21日Instagram正式登录Windows Phone 8平台。\n\n### 特性：\n>☆ 100%免费自定义设计的过滤器和边框，例如XPro-II、Earlybird、Rise、Amaro、Hudson、Lo-fi、Sutro、Toaster、 Brannan、Inkwell、Walden、Hefe、Nashville、1977等等[8] \n☆ 实时分享到新浪微博、Facebook、Twitter、Flickr、Tumblr和Foursquare\n☆ 平行和放射状移轴模糊特效可提供额外的景深效果[9] \n☆ 上传不受限，即拍即传即分享\n☆ 通过接收和发送赞和评论与朋友互动\n☆ iPhone前置和后置摄像头的全面支持\n\n可能大家用的时候会感到很奇怪，**怎么网页版的instagrame不支持上传照片么**？可能是instagrame更注重生活中的抓拍吧，生活中还是使用移动设备多一点，所以它这个设计也是符合它的理念的（快速记录生活）。\n\ninstagrame分享图片的时候可以选择地理位置（最后还可以生成图片地图哦^_^），也可以选择分享的对象，非常的个性化，可以看下效果哦！\n![图片地图](/assets/img/instagrame.png \"图片地图\")\n\n## 最后说两句\ninstagrame还可以上传小视频，有点像现在的微信小视频之类的，不过只能最多15秒。\n总之，我还是比较喜欢instagrame来收录生活中的场景的。\n\n参考资料：\n1. http://baike.baidu.com/link?url=QoodiA5Hzcnxlq268Lk3jkOPedAy3ICAVI-T6LKpay6A08o6UaTSU4tUrpqQuXJhFix9R3IAYzWN0KFY01iPRa\n2. http://1016990109.github.io/2016/05/20/instagrame/","source":"_posts/instagrame.md","raw":"---\ntitle: 开始我的instagrame\ndate: 2016-05-20 15:09:39\ntags: \n\t- 随笔\ncategories: 生活\n---\n## 一次偶然的机会，我认识了instagrame\n一天，一个偶然，我逛了下[litten](http://litten.github.io/ \"litten的博客\")的博客，发现了他把自己的照片分享在了博客上，于是我便很好奇博主是用了什么方法分享的。于是我查看了博主搭建博客的过程，了解到他是分享了在instagrame上的照片，这就是我第一次认识instagrame。\n\n## 开始了解instagrame\n秉着好学的心态，我也想在自己的博客上搭建一个这样分享照片的平台，就这样我开始了我的instagrame之旅。\n<!-- more -->\n### 百度百科的介绍：\n>Instagram是一款最初运行在iOS平台上的移动应用，以一种快速、美妙和有趣的方式将你随时抓拍下的图片分享彼此，安卓版Instagram于2012年4月3日起登陆Android应用商店Google Play。2012年4月10号，Facebook宣布以10亿美元收购Instagram。2012年10月25号，Facebook以总值7.15亿美元收购Instagram。2012年12月，Facebook旗下的图片共享服务Instagram因其使用图片共享服务的新条款而在互联网上引起轩然大波，Instagram对此进行了澄清，称不会在广告中使用或销售用户的照片，从而打消了用户的顾虑。北京时间2013年10月22日，诺基亚宣布instagram将会入驻Windows Phone市场，11月21日Instagram正式登录Windows Phone 8平台。\n\n### 特性：\n>☆ 100%免费自定义设计的过滤器和边框，例如XPro-II、Earlybird、Rise、Amaro、Hudson、Lo-fi、Sutro、Toaster、 Brannan、Inkwell、Walden、Hefe、Nashville、1977等等[8] \n☆ 实时分享到新浪微博、Facebook、Twitter、Flickr、Tumblr和Foursquare\n☆ 平行和放射状移轴模糊特效可提供额外的景深效果[9] \n☆ 上传不受限，即拍即传即分享\n☆ 通过接收和发送赞和评论与朋友互动\n☆ iPhone前置和后置摄像头的全面支持\n\n可能大家用的时候会感到很奇怪，**怎么网页版的instagrame不支持上传照片么**？可能是instagrame更注重生活中的抓拍吧，生活中还是使用移动设备多一点，所以它这个设计也是符合它的理念的（快速记录生活）。\n\ninstagrame分享图片的时候可以选择地理位置（最后还可以生成图片地图哦^_^），也可以选择分享的对象，非常的个性化，可以看下效果哦！\n![图片地图](/assets/img/instagrame.png \"图片地图\")\n\n## 最后说两句\ninstagrame还可以上传小视频，有点像现在的微信小视频之类的，不过只能最多15秒。\n总之，我还是比较喜欢instagrame来收录生活中的场景的。\n\n参考资料：\n1. http://baike.baidu.com/link?url=QoodiA5Hzcnxlq268Lk3jkOPedAy3ICAVI-T6LKpay6A08o6UaTSU4tUrpqQuXJhFix9R3IAYzWN0KFY01iPRa\n2. http://1016990109.github.io/2016/05/20/instagrame/","slug":"instagrame","published":1,"updated":"2018-04-17T07:29:54.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh692bww000amzfy9k1nomij","content":"<h2 id=\"一次偶然的机会，我认识了instagrame\"><a href=\"#一次偶然的机会，我认识了instagrame\" class=\"headerlink\" title=\"一次偶然的机会，我认识了instagrame\"></a>一次偶然的机会，我认识了instagrame</h2><p>一天，一个偶然，我逛了下<a href=\"http://litten.github.io/\" title=\"litten的博客\" target=\"_blank\" rel=\"noopener\">litten</a>的博客，发现了他把自己的照片分享在了博客上，于是我便很好奇博主是用了什么方法分享的。于是我查看了博主搭建博客的过程，了解到他是分享了在instagrame上的照片，这就是我第一次认识instagrame。</p>\n<h2 id=\"开始了解instagrame\"><a href=\"#开始了解instagrame\" class=\"headerlink\" title=\"开始了解instagrame\"></a>开始了解instagrame</h2><p>秉着好学的心态，我也想在自己的博客上搭建一个这样分享照片的平台，就这样我开始了我的instagrame之旅。<br><a id=\"more\"></a></p>\n<h3 id=\"百度百科的介绍：\"><a href=\"#百度百科的介绍：\" class=\"headerlink\" title=\"百度百科的介绍：\"></a>百度百科的介绍：</h3><blockquote>\n<p>Instagram是一款最初运行在iOS平台上的移动应用，以一种快速、美妙和有趣的方式将你随时抓拍下的图片分享彼此，安卓版Instagram于2012年4月3日起登陆Android应用商店Google Play。2012年4月10号，Facebook宣布以10亿美元收购Instagram。2012年10月25号，Facebook以总值7.15亿美元收购Instagram。2012年12月，Facebook旗下的图片共享服务Instagram因其使用图片共享服务的新条款而在互联网上引起轩然大波，Instagram对此进行了澄清，称不会在广告中使用或销售用户的照片，从而打消了用户的顾虑。北京时间2013年10月22日，诺基亚宣布instagram将会入驻Windows Phone市场，11月21日Instagram正式登录Windows Phone 8平台。</p>\n</blockquote>\n<h3 id=\"特性：\"><a href=\"#特性：\" class=\"headerlink\" title=\"特性：\"></a>特性：</h3><blockquote>\n<p>☆ 100%免费自定义设计的过滤器和边框，例如XPro-II、Earlybird、Rise、Amaro、Hudson、Lo-fi、Sutro、Toaster、 Brannan、Inkwell、Walden、Hefe、Nashville、1977等等[8]<br>☆ 实时分享到新浪微博、Facebook、Twitter、Flickr、Tumblr和Foursquare<br>☆ 平行和放射状移轴模糊特效可提供额外的景深效果[9]<br>☆ 上传不受限，即拍即传即分享<br>☆ 通过接收和发送赞和评论与朋友互动<br>☆ iPhone前置和后置摄像头的全面支持</p>\n</blockquote>\n<p>可能大家用的时候会感到很奇怪，<strong>怎么网页版的instagrame不支持上传照片么</strong>？可能是instagrame更注重生活中的抓拍吧，生活中还是使用移动设备多一点，所以它这个设计也是符合它的理念的（快速记录生活）。</p>\n<p>instagrame分享图片的时候可以选择地理位置（最后还可以生成图片地图哦^_^），也可以选择分享的对象，非常的个性化，可以看下效果哦！<br><img src=\"/assets/img/instagrame.png\" alt=\"图片地图\" title=\"图片地图\"></p>\n<h2 id=\"最后说两句\"><a href=\"#最后说两句\" class=\"headerlink\" title=\"最后说两句\"></a>最后说两句</h2><p>instagrame还可以上传小视频，有点像现在的微信小视频之类的，不过只能最多15秒。<br>总之，我还是比较喜欢instagrame来收录生活中的场景的。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"http://baike.baidu.com/link?url=QoodiA5Hzcnxlq268Lk3jkOPedAy3ICAVI-T6LKpay6A08o6UaTSU4tUrpqQuXJhFix9R3IAYzWN0KFY01iPRa\" target=\"_blank\" rel=\"noopener\">http://baike.baidu.com/link?url=QoodiA5Hzcnxlq268Lk3jkOPedAy3ICAVI-T6LKpay6A08o6UaTSU4tUrpqQuXJhFix9R3IAYzWN0KFY01iPRa</a></li>\n<li><a href=\"http://1016990109.github.io/2016/05/20/instagrame/\">http://1016990109.github.io/2016/05/20/instagrame/</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"一次偶然的机会，我认识了instagrame\"><a href=\"#一次偶然的机会，我认识了instagrame\" class=\"headerlink\" title=\"一次偶然的机会，我认识了instagrame\"></a>一次偶然的机会，我认识了instagrame</h2><p>一天，一个偶然，我逛了下<a href=\"http://litten.github.io/\" title=\"litten的博客\" target=\"_blank\" rel=\"noopener\">litten</a>的博客，发现了他把自己的照片分享在了博客上，于是我便很好奇博主是用了什么方法分享的。于是我查看了博主搭建博客的过程，了解到他是分享了在instagrame上的照片，这就是我第一次认识instagrame。</p>\n<h2 id=\"开始了解instagrame\"><a href=\"#开始了解instagrame\" class=\"headerlink\" title=\"开始了解instagrame\"></a>开始了解instagrame</h2><p>秉着好学的心态，我也想在自己的博客上搭建一个这样分享照片的平台，就这样我开始了我的instagrame之旅。<br>","more":"</p>\n<h3 id=\"百度百科的介绍：\"><a href=\"#百度百科的介绍：\" class=\"headerlink\" title=\"百度百科的介绍：\"></a>百度百科的介绍：</h3><blockquote>\n<p>Instagram是一款最初运行在iOS平台上的移动应用，以一种快速、美妙和有趣的方式将你随时抓拍下的图片分享彼此，安卓版Instagram于2012年4月3日起登陆Android应用商店Google Play。2012年4月10号，Facebook宣布以10亿美元收购Instagram。2012年10月25号，Facebook以总值7.15亿美元收购Instagram。2012年12月，Facebook旗下的图片共享服务Instagram因其使用图片共享服务的新条款而在互联网上引起轩然大波，Instagram对此进行了澄清，称不会在广告中使用或销售用户的照片，从而打消了用户的顾虑。北京时间2013年10月22日，诺基亚宣布instagram将会入驻Windows Phone市场，11月21日Instagram正式登录Windows Phone 8平台。</p>\n</blockquote>\n<h3 id=\"特性：\"><a href=\"#特性：\" class=\"headerlink\" title=\"特性：\"></a>特性：</h3><blockquote>\n<p>☆ 100%免费自定义设计的过滤器和边框，例如XPro-II、Earlybird、Rise、Amaro、Hudson、Lo-fi、Sutro、Toaster、 Brannan、Inkwell、Walden、Hefe、Nashville、1977等等[8]<br>☆ 实时分享到新浪微博、Facebook、Twitter、Flickr、Tumblr和Foursquare<br>☆ 平行和放射状移轴模糊特效可提供额外的景深效果[9]<br>☆ 上传不受限，即拍即传即分享<br>☆ 通过接收和发送赞和评论与朋友互动<br>☆ iPhone前置和后置摄像头的全面支持</p>\n</blockquote>\n<p>可能大家用的时候会感到很奇怪，<strong>怎么网页版的instagrame不支持上传照片么</strong>？可能是instagrame更注重生活中的抓拍吧，生活中还是使用移动设备多一点，所以它这个设计也是符合它的理念的（快速记录生活）。</p>\n<p>instagrame分享图片的时候可以选择地理位置（最后还可以生成图片地图哦^_^），也可以选择分享的对象，非常的个性化，可以看下效果哦！<br><img src=\"/assets/img/instagrame.png\" alt=\"图片地图\" title=\"图片地图\"></p>\n<h2 id=\"最后说两句\"><a href=\"#最后说两句\" class=\"headerlink\" title=\"最后说两句\"></a>最后说两句</h2><p>instagrame还可以上传小视频，有点像现在的微信小视频之类的，不过只能最多15秒。<br>总之，我还是比较喜欢instagrame来收录生活中的场景的。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"http://baike.baidu.com/link?url=QoodiA5Hzcnxlq268Lk3jkOPedAy3ICAVI-T6LKpay6A08o6UaTSU4tUrpqQuXJhFix9R3IAYzWN0KFY01iPRa\" target=\"_blank\" rel=\"noopener\">http://baike.baidu.com/link?url=QoodiA5Hzcnxlq268Lk3jkOPedAy3ICAVI-T6LKpay6A08o6UaTSU4tUrpqQuXJhFix9R3IAYzWN0KFY01iPRa</a></li>\n<li><a href=\"http://1016990109.github.io/2016/05/20/instagrame/\">http://1016990109.github.io/2016/05/20/instagrame/</a></li>\n</ol>"},{"title":"rbac分析（php源码）","date":"2016-05-23T14:23:47.000Z","_content":"## rbac简介\n>基于角色的访问控制（Role-Based Access Control）作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。\n\n<!-- more -->\n用一张图来简单地描述一下\n\n![rbac图解](/assets/img/rbac_intro.png)\n\nrbac有3个重要概念：**用户**、**角色**、**权限**。通俗地来说，就是把若干个**权限**分配给某个**角色**，然后在需要时把若干个**角色**分配给指定的**用户**，rbac就是通过这种方式实现访问控制的。\n\n管理员通过分配给一个用户角色来允许该用户可以做某些事情。\n\n**RBAC支持三个著名的安全原则**：\n1. 最小权限原则\n将其角色配置成其完成任务所需要的最小的权限集\n2. 责任分离原则\n可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一过帐\n3. 数据抽象\n可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限\n\n\n## 为什么使用rbac\n普通的ACL在权限越来越多的时候需要维护的权限太多，这造成了ACL的瓶颈。而rbac可以有效地解决这个问题。\n\n## 特点\n* 仍然有很多权限存在于系统（问题）\n* 人员移动的时候只需要改变人员的角色\n* 维护大量的权限仍然是个问题\n* 维护分配给每个角色的权限比较容易\n* 角色的权限分配需要双重检查确保不会分配错误的权限给任何角色\n\n## 一款开源的rbac库——PHP-RBAC\n### 简介\n[PHP-RBAC](http://phprbac.net/ \"PHP-RBAC\")是php的一个简单库，实现了rbac一些基本的功能（不包括用户组），它为开发者提供了NIST Level 2 Standard Role Based Access Control。\n\n下面是PHP-RBAC的一个demo：它实现了角色的分层管理，更贴近实际。\n![rbac-demo](http://phprbac.net/img/rbac.png)\n\n我自己简单地试了下库，代码是这样：\n``` php\n<?php\n// turn on all errors\nerror_reporting(E_ALL);\nuse PhpRbac\\Rbac;\n// autoloader\nrequire dirname(__DIR__) . '/autoload.php';\n\n$test = new Test();\n$test->myTest();\n// myTest();\n\nclass Test {\n\tpublic function test(){\n\t\t$rbac = new Rbac('unit_test');\n\t}\n\n\tpublic function myTest(){\n\n\t\t$rbac = new Rbac();\n\t\t$rbac->reset(true);\n\n\t\t// Create a Permission\n\t\t$perm_id = $rbac->Permissions->add('delete_posts', 'Can delete forum posts');\n\t\t$perm_id2 = $rbac->Permissions->add('add_posts', 'Can add forum posts');\n\n\t\t// Create a Role\n\t\t$role_id = $rbac->Roles->add('forum_moderator', 'User can moderate forums');\n\n\t\t// The following are equivalent statements\n\t\t$rbac->assign($role_id, $perm_id);\n\t\t$rbac->assign($role_id, $perm_id2);\n\n\t\t$rbac->Users->assign($role_id, 5);\n\n\t\t$res = $rbac->Roles->permissions(\"2\");\n\n\t\tforeach ($res as $perm) {\n\t\t\tprint($rbac->Permissions->getDescription($perm).' ');\n\t\t\tprint($rbac->Permissions->depth($perm).' ');\n\t\t\tprint($rbac->Permissions->getPath($perm).' ');\n\t\t\techo \"</br>\";\n\t\t}\n\n\t}\n}\n```\n结果：\n![运行结果](/assets/img/phprbac_result.png)\n使用非常容易吧，这是一个轻量的库，只有几百k的大小，所以对于一些对权限管理要求不是特别复杂的（没有用户组、分类等）系统可以考虑使用哦！\n\n### 分析\n\nPHP-RBAC的表设计同许多rbac的软件类似：\n![rbac表](/assets/img/rbac_table.png)\n![php-rbac表](/assets/img/phprbac_table.png)\n\nPHP-RBAC分层实现：\n使用树形结构实现（嵌套集合）：\n![树形结构数据库实现](/assets/img/phprbac_tree.png)\n![php-rbac例子](/assets/img/phprbac_tree_em.png)\n\nEnd.\n*关于rbac的扩展以后有时间再给大家讲讲。*\n\n参考资料：\n1. http://baike.baidu.com/link?url=5FPK3srV0UpUKEJProX7MIJDmX4FFlEp8tQI5VQ8-pnI1xMUv8BY9E4TDeM89astDTGW9Mr0uBWOXpwk_2egr_\n2. http://phprbac.net/","source":"_posts/rbac-php.md","raw":"---\ntitle: rbac分析（php源码）\ndate: 2016-05-23 22:23:47\ntags:\n\t- 源码\n\t- php\n---\n## rbac简介\n>基于角色的访问控制（Role-Based Access Control）作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。\n\n<!-- more -->\n用一张图来简单地描述一下\n\n![rbac图解](/assets/img/rbac_intro.png)\n\nrbac有3个重要概念：**用户**、**角色**、**权限**。通俗地来说，就是把若干个**权限**分配给某个**角色**，然后在需要时把若干个**角色**分配给指定的**用户**，rbac就是通过这种方式实现访问控制的。\n\n管理员通过分配给一个用户角色来允许该用户可以做某些事情。\n\n**RBAC支持三个著名的安全原则**：\n1. 最小权限原则\n将其角色配置成其完成任务所需要的最小的权限集\n2. 责任分离原则\n可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一过帐\n3. 数据抽象\n可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限\n\n\n## 为什么使用rbac\n普通的ACL在权限越来越多的时候需要维护的权限太多，这造成了ACL的瓶颈。而rbac可以有效地解决这个问题。\n\n## 特点\n* 仍然有很多权限存在于系统（问题）\n* 人员移动的时候只需要改变人员的角色\n* 维护大量的权限仍然是个问题\n* 维护分配给每个角色的权限比较容易\n* 角色的权限分配需要双重检查确保不会分配错误的权限给任何角色\n\n## 一款开源的rbac库——PHP-RBAC\n### 简介\n[PHP-RBAC](http://phprbac.net/ \"PHP-RBAC\")是php的一个简单库，实现了rbac一些基本的功能（不包括用户组），它为开发者提供了NIST Level 2 Standard Role Based Access Control。\n\n下面是PHP-RBAC的一个demo：它实现了角色的分层管理，更贴近实际。\n![rbac-demo](http://phprbac.net/img/rbac.png)\n\n我自己简单地试了下库，代码是这样：\n``` php\n<?php\n// turn on all errors\nerror_reporting(E_ALL);\nuse PhpRbac\\Rbac;\n// autoloader\nrequire dirname(__DIR__) . '/autoload.php';\n\n$test = new Test();\n$test->myTest();\n// myTest();\n\nclass Test {\n\tpublic function test(){\n\t\t$rbac = new Rbac('unit_test');\n\t}\n\n\tpublic function myTest(){\n\n\t\t$rbac = new Rbac();\n\t\t$rbac->reset(true);\n\n\t\t// Create a Permission\n\t\t$perm_id = $rbac->Permissions->add('delete_posts', 'Can delete forum posts');\n\t\t$perm_id2 = $rbac->Permissions->add('add_posts', 'Can add forum posts');\n\n\t\t// Create a Role\n\t\t$role_id = $rbac->Roles->add('forum_moderator', 'User can moderate forums');\n\n\t\t// The following are equivalent statements\n\t\t$rbac->assign($role_id, $perm_id);\n\t\t$rbac->assign($role_id, $perm_id2);\n\n\t\t$rbac->Users->assign($role_id, 5);\n\n\t\t$res = $rbac->Roles->permissions(\"2\");\n\n\t\tforeach ($res as $perm) {\n\t\t\tprint($rbac->Permissions->getDescription($perm).' ');\n\t\t\tprint($rbac->Permissions->depth($perm).' ');\n\t\t\tprint($rbac->Permissions->getPath($perm).' ');\n\t\t\techo \"</br>\";\n\t\t}\n\n\t}\n}\n```\n结果：\n![运行结果](/assets/img/phprbac_result.png)\n使用非常容易吧，这是一个轻量的库，只有几百k的大小，所以对于一些对权限管理要求不是特别复杂的（没有用户组、分类等）系统可以考虑使用哦！\n\n### 分析\n\nPHP-RBAC的表设计同许多rbac的软件类似：\n![rbac表](/assets/img/rbac_table.png)\n![php-rbac表](/assets/img/phprbac_table.png)\n\nPHP-RBAC分层实现：\n使用树形结构实现（嵌套集合）：\n![树形结构数据库实现](/assets/img/phprbac_tree.png)\n![php-rbac例子](/assets/img/phprbac_tree_em.png)\n\nEnd.\n*关于rbac的扩展以后有时间再给大家讲讲。*\n\n参考资料：\n1. http://baike.baidu.com/link?url=5FPK3srV0UpUKEJProX7MIJDmX4FFlEp8tQI5VQ8-pnI1xMUv8BY9E4TDeM89astDTGW9Mr0uBWOXpwk_2egr_\n2. http://phprbac.net/","slug":"rbac-php","published":1,"updated":"2018-04-17T08:45:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjh692bwy000bmzfy73fcayw2","content":"<h2 id=\"rbac简介\"><a href=\"#rbac简介\" class=\"headerlink\" title=\"rbac简介\"></a>rbac简介</h2><blockquote>\n<p>基于角色的访问控制（Role-Based Access Control）作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>用一张图来简单地描述一下</p>\n<p><img src=\"/assets/img/rbac_intro.png\" alt=\"rbac图解\"></p>\n<p>rbac有3个重要概念：<strong>用户</strong>、<strong>角色</strong>、<strong>权限</strong>。通俗地来说，就是把若干个<strong>权限</strong>分配给某个<strong>角色</strong>，然后在需要时把若干个<strong>角色</strong>分配给指定的<strong>用户</strong>，rbac就是通过这种方式实现访问控制的。</p>\n<p>管理员通过分配给一个用户角色来允许该用户可以做某些事情。</p>\n<p><strong>RBAC支持三个著名的安全原则</strong>：</p>\n<ol>\n<li>最小权限原则<br>将其角色配置成其完成任务所需要的最小的权限集</li>\n<li>责任分离原则<br>可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一过帐</li>\n<li>数据抽象<br>可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限</li>\n</ol>\n<h2 id=\"为什么使用rbac\"><a href=\"#为什么使用rbac\" class=\"headerlink\" title=\"为什么使用rbac\"></a>为什么使用rbac</h2><p>普通的ACL在权限越来越多的时候需要维护的权限太多，这造成了ACL的瓶颈。而rbac可以有效地解决这个问题。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>仍然有很多权限存在于系统（问题）</li>\n<li>人员移动的时候只需要改变人员的角色</li>\n<li>维护大量的权限仍然是个问题</li>\n<li>维护分配给每个角色的权限比较容易</li>\n<li>角色的权限分配需要双重检查确保不会分配错误的权限给任何角色</li>\n</ul>\n<h2 id=\"一款开源的rbac库——PHP-RBAC\"><a href=\"#一款开源的rbac库——PHP-RBAC\" class=\"headerlink\" title=\"一款开源的rbac库——PHP-RBAC\"></a>一款开源的rbac库——PHP-RBAC</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><a href=\"http://phprbac.net/\" title=\"PHP-RBAC\" target=\"_blank\" rel=\"noopener\">PHP-RBAC</a>是php的一个简单库，实现了rbac一些基本的功能（不包括用户组），它为开发者提供了NIST Level 2 Standard Role Based Access Control。</p>\n<p>下面是PHP-RBAC的一个demo：它实现了角色的分层管理，更贴近实际。<br><img src=\"http://phprbac.net/img/rbac.png\" alt=\"rbac-demo\"></p>\n<p>我自己简单地试了下库，代码是这样：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// turn on all errors</span></span><br><span class=\"line\">error_reporting(E_ALL);</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">PhpRbac</span>\\<span class=\"title\">Rbac</span>;</span><br><span class=\"line\"><span class=\"comment\">// autoloader</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> dirname(<span class=\"keyword\">__DIR__</span>) . <span class=\"string\">'/autoload.php'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$test = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\">$test-&gt;myTest();</span><br><span class=\"line\"><span class=\"comment\">// myTest();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t$rbac = <span class=\"keyword\">new</span> Rbac(<span class=\"string\">'unit_test'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myTest</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$rbac = <span class=\"keyword\">new</span> Rbac();</span><br><span class=\"line\">\t\t$rbac-&gt;reset(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Create a Permission</span></span><br><span class=\"line\">\t\t$perm_id = $rbac-&gt;Permissions-&gt;add(<span class=\"string\">'delete_posts'</span>, <span class=\"string\">'Can delete forum posts'</span>);</span><br><span class=\"line\">\t\t$perm_id2 = $rbac-&gt;Permissions-&gt;add(<span class=\"string\">'add_posts'</span>, <span class=\"string\">'Can add forum posts'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Create a Role</span></span><br><span class=\"line\">\t\t$role_id = $rbac-&gt;Roles-&gt;add(<span class=\"string\">'forum_moderator'</span>, <span class=\"string\">'User can moderate forums'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// The following are equivalent statements</span></span><br><span class=\"line\">\t\t$rbac-&gt;assign($role_id, $perm_id);</span><br><span class=\"line\">\t\t$rbac-&gt;assign($role_id, $perm_id2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$rbac-&gt;Users-&gt;assign($role_id, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$res = $rbac-&gt;Roles-&gt;permissions(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">foreach</span> ($res <span class=\"keyword\">as</span> $perm) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">print</span>($rbac-&gt;Permissions-&gt;getDescription($perm).<span class=\"string\">' '</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">print</span>($rbac-&gt;Permissions-&gt;depth($perm).<span class=\"string\">' '</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">print</span>($rbac-&gt;Permissions-&gt;getPath($perm).<span class=\"string\">' '</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">echo</span> <span class=\"string\">\"&lt;/br&gt;\"</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><img src=\"/assets/img/phprbac_result.png\" alt=\"运行结果\"><br>使用非常容易吧，这是一个轻量的库，只有几百k的大小，所以对于一些对权限管理要求不是特别复杂的（没有用户组、分类等）系统可以考虑使用哦！</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>PHP-RBAC的表设计同许多rbac的软件类似：<br><img src=\"/assets/img/rbac_table.png\" alt=\"rbac表\"><br><img src=\"/assets/img/phprbac_table.png\" alt=\"php-rbac表\"></p>\n<p>PHP-RBAC分层实现：<br>使用树形结构实现（嵌套集合）：<br><img src=\"/assets/img/phprbac_tree.png\" alt=\"树形结构数据库实现\"><br><img src=\"/assets/img/phprbac_tree_em.png\" alt=\"php-rbac例子\"></p>\n<p>End.<br><em>关于rbac的扩展以后有时间再给大家讲讲。</em></p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"http://baike.baidu.com/link?url=5FPK3srV0UpUKEJProX7MIJDmX4FFlEp8tQI5VQ8-pnI1xMUv8BY9E4TDeM89astDTGW9Mr0uBWOXpwk_2egr\" target=\"_blank\" rel=\"noopener\">http://baike.baidu.com/link?url=5FPK3srV0UpUKEJProX7MIJDmX4FFlEp8tQI5VQ8-pnI1xMUv8BY9E4TDeM89astDTGW9Mr0uBWOXpwk_2egr</a>_</li>\n<li><a href=\"http://phprbac.net/\" target=\"_blank\" rel=\"noopener\">http://phprbac.net/</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"rbac简介\"><a href=\"#rbac简介\" class=\"headerlink\" title=\"rbac简介\"></a>rbac简介</h2><blockquote>\n<p>基于角色的访问控制（Role-Based Access Control）作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。</p>\n</blockquote>","more":"<p>用一张图来简单地描述一下</p>\n<p><img src=\"/assets/img/rbac_intro.png\" alt=\"rbac图解\"></p>\n<p>rbac有3个重要概念：<strong>用户</strong>、<strong>角色</strong>、<strong>权限</strong>。通俗地来说，就是把若干个<strong>权限</strong>分配给某个<strong>角色</strong>，然后在需要时把若干个<strong>角色</strong>分配给指定的<strong>用户</strong>，rbac就是通过这种方式实现访问控制的。</p>\n<p>管理员通过分配给一个用户角色来允许该用户可以做某些事情。</p>\n<p><strong>RBAC支持三个著名的安全原则</strong>：</p>\n<ol>\n<li>最小权限原则<br>将其角色配置成其完成任务所需要的最小的权限集</li>\n<li>责任分离原则<br>可以通过调用相互独立互斥的角色来共同完成敏感的任务而体现，比如要求一个计帐员和财务管理员共参与同一过帐</li>\n<li>数据抽象<br>可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型的读、写、执行权限</li>\n</ol>\n<h2 id=\"为什么使用rbac\"><a href=\"#为什么使用rbac\" class=\"headerlink\" title=\"为什么使用rbac\"></a>为什么使用rbac</h2><p>普通的ACL在权限越来越多的时候需要维护的权限太多，这造成了ACL的瓶颈。而rbac可以有效地解决这个问题。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>仍然有很多权限存在于系统（问题）</li>\n<li>人员移动的时候只需要改变人员的角色</li>\n<li>维护大量的权限仍然是个问题</li>\n<li>维护分配给每个角色的权限比较容易</li>\n<li>角色的权限分配需要双重检查确保不会分配错误的权限给任何角色</li>\n</ul>\n<h2 id=\"一款开源的rbac库——PHP-RBAC\"><a href=\"#一款开源的rbac库——PHP-RBAC\" class=\"headerlink\" title=\"一款开源的rbac库——PHP-RBAC\"></a>一款开源的rbac库——PHP-RBAC</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><a href=\"http://phprbac.net/\" title=\"PHP-RBAC\" target=\"_blank\" rel=\"noopener\">PHP-RBAC</a>是php的一个简单库，实现了rbac一些基本的功能（不包括用户组），它为开发者提供了NIST Level 2 Standard Role Based Access Control。</p>\n<p>下面是PHP-RBAC的一个demo：它实现了角色的分层管理，更贴近实际。<br><img src=\"http://phprbac.net/img/rbac.png\" alt=\"rbac-demo\"></p>\n<p>我自己简单地试了下库，代码是这样：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// turn on all errors</span></span><br><span class=\"line\">error_reporting(E_ALL);</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">PhpRbac</span>\\<span class=\"title\">Rbac</span>;</span><br><span class=\"line\"><span class=\"comment\">// autoloader</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> dirname(<span class=\"keyword\">__DIR__</span>) . <span class=\"string\">'/autoload.php'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$test = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\">$test-&gt;myTest();</span><br><span class=\"line\"><span class=\"comment\">// myTest();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t$rbac = <span class=\"keyword\">new</span> Rbac(<span class=\"string\">'unit_test'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myTest</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$rbac = <span class=\"keyword\">new</span> Rbac();</span><br><span class=\"line\">\t\t$rbac-&gt;reset(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Create a Permission</span></span><br><span class=\"line\">\t\t$perm_id = $rbac-&gt;Permissions-&gt;add(<span class=\"string\">'delete_posts'</span>, <span class=\"string\">'Can delete forum posts'</span>);</span><br><span class=\"line\">\t\t$perm_id2 = $rbac-&gt;Permissions-&gt;add(<span class=\"string\">'add_posts'</span>, <span class=\"string\">'Can add forum posts'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Create a Role</span></span><br><span class=\"line\">\t\t$role_id = $rbac-&gt;Roles-&gt;add(<span class=\"string\">'forum_moderator'</span>, <span class=\"string\">'User can moderate forums'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// The following are equivalent statements</span></span><br><span class=\"line\">\t\t$rbac-&gt;assign($role_id, $perm_id);</span><br><span class=\"line\">\t\t$rbac-&gt;assign($role_id, $perm_id2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$rbac-&gt;Users-&gt;assign($role_id, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t$res = $rbac-&gt;Roles-&gt;permissions(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">foreach</span> ($res <span class=\"keyword\">as</span> $perm) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">print</span>($rbac-&gt;Permissions-&gt;getDescription($perm).<span class=\"string\">' '</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">print</span>($rbac-&gt;Permissions-&gt;depth($perm).<span class=\"string\">' '</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">print</span>($rbac-&gt;Permissions-&gt;getPath($perm).<span class=\"string\">' '</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">echo</span> <span class=\"string\">\"&lt;/br&gt;\"</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><img src=\"/assets/img/phprbac_result.png\" alt=\"运行结果\"><br>使用非常容易吧，这是一个轻量的库，只有几百k的大小，所以对于一些对权限管理要求不是特别复杂的（没有用户组、分类等）系统可以考虑使用哦！</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>PHP-RBAC的表设计同许多rbac的软件类似：<br><img src=\"/assets/img/rbac_table.png\" alt=\"rbac表\"><br><img src=\"/assets/img/phprbac_table.png\" alt=\"php-rbac表\"></p>\n<p>PHP-RBAC分层实现：<br>使用树形结构实现（嵌套集合）：<br><img src=\"/assets/img/phprbac_tree.png\" alt=\"树形结构数据库实现\"><br><img src=\"/assets/img/phprbac_tree_em.png\" alt=\"php-rbac例子\"></p>\n<p>End.<br><em>关于rbac的扩展以后有时间再给大家讲讲。</em></p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"http://baike.baidu.com/link?url=5FPK3srV0UpUKEJProX7MIJDmX4FFlEp8tQI5VQ8-pnI1xMUv8BY9E4TDeM89astDTGW9Mr0uBWOXpwk_2egr\" target=\"_blank\" rel=\"noopener\">http://baike.baidu.com/link?url=5FPK3srV0UpUKEJProX7MIJDmX4FFlEp8tQI5VQ8-pnI1xMUv8BY9E4TDeM89astDTGW9Mr0uBWOXpwk_2egr</a>_</li>\n<li><a href=\"http://phprbac.net/\" target=\"_blank\" rel=\"noopener\">http://phprbac.net/</a></li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjh692bww000amzfy9k1nomij","category_id":"cjh692bx2000dmzfy5lzigsyd","_id":"cjh692bx5000imzfycme48yql"}],"PostTag":[{"post_id":"cjh692bwh0000mzfy23pac4wc","tag_id":"cjh692bwq0004mzfyse2pz82x","_id":"cjh692bwv0009mzfy4t2cunnn"},{"post_id":"cjh692bwn0002mzfyiws7lst9","tag_id":"cjh692bwv0008mzfyz2bu1kbw","_id":"cjh692bx3000emzfybw80jm4y"},{"post_id":"cjh692bws0005mzfytyjo03g9","tag_id":"cjh692bx2000cmzfycawu9zpg","_id":"cjh692bx4000gmzfy4vxrav2v"},{"post_id":"cjh692bwt0006mzfy0ritrawb","tag_id":"cjh692bwv0008mzfyz2bu1kbw","_id":"cjh692bx6000jmzfyx5y5xh3w"},{"post_id":"cjh692bwu0007mzfyfsrgsha6","tag_id":"cjh692bwv0008mzfyz2bu1kbw","_id":"cjh692bx6000lmzfyyc21dzag"},{"post_id":"cjh692bww000amzfy9k1nomij","tag_id":"cjh692bx6000kmzfyge3sg0ly","_id":"cjh692bx7000nmzfyt70vmq9j"},{"post_id":"cjh692bwy000bmzfy73fcayw2","tag_id":"cjh692bx7000mmzfyh7w5gl6y","_id":"cjh692bx8000pmzfyx92qgod7"},{"post_id":"cjh692bwy000bmzfy73fcayw2","tag_id":"cjh692bx8000omzfyqae3th5y","_id":"cjh692bx9000qmzfy7u7xmy57"}],"Tag":[{"name":"读书笔记","_id":"cjh692bwq0004mzfyse2pz82x"},{"name":"前端","_id":"cjh692bwv0008mzfyz2bu1kbw"},{"name":"python","_id":"cjh692bx2000cmzfycawu9zpg"},{"name":"随笔","_id":"cjh692bx6000kmzfyge3sg0ly"},{"name":"源码","_id":"cjh692bx7000mmzfyh7w5gl6y"},{"name":"php","_id":"cjh692bx8000omzfyqae3th5y"}]}}