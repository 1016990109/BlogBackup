---
title: Linux 命令 —— 常见任务和基本工具
date: 2018-10-29 11:13:55
tags:
  - Linux
---

## 软件包管理

### 打包系统

不同的 `Linux` 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营： `Debian` 的”.deb”，和红帽的”.rpm”。

表格: 主要的包管理系统家族

| 包管理系统           | 发行版 (部分列表)                                                       |
| -------------------- | ----------------------------------------------------------------------- |
| Debian Style (.deb)  | Debian, Ubuntu, Xandros, Linspire                                       |
| Red Hat Style (.rpm) | Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS |

<!-- more -->

### 包文件

在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包 可能由大量程序以及支持这些程序的数据文件组成。除了安装文件之外，软件包文件也包括 关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安装后脚本， 这些脚本用来在软件安装之前和之后执行配置任务。

软件包文件是由软件包维护者创建的，他通常是（但不总是）一名软件发行商的雇员。软件维护者从上游提供商（程序作者）那里得到软件源码，然后编译源码，创建软件包元数据以及所需要的 安装脚本。通常，软件包维护者要把所做的修改应用到最初的源码当中，来提高此软件与 `Linux` 发行版其它部分的融合性。

### 资源库

虽然某些软件项目选择执行他们自己的打包和发布策略，但是现在大多数软件包是由发行商和感兴趣 的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资源库可能 包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。

### 依赖性

现代的软件包管理系统都提供了一些依赖项解析方法，以确保安装软件包时，其所有的依赖也被安装。

### 上层和底层软件包工具

软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件， 和上层工具，完成元数据搜索和依赖解析。

表格: 包管理工具

| 发行版                                    | 底层工具 | 上层工具          |
| ----------------------------------------- | -------- | ----------------- |
| Debian-Style                              | dpkg     | apt-get, aptitude |
| Fedora, Red Hat, Enterprise Linux, CentOS | rpm      | yum               |

### 查找资源库中的软件包

表格：软件包查找工具

| 风格    | 命令                                           |
| ------- | ---------------------------------------------- |
| Debian  | apt-get update; apt-cache search search_string |
| Red Hat | yum search search_string                       |

### 从资源库中安装一个软件包

表格: 软件包安装命令

| 风格    | 命令                                         |
| ------- | -------------------------------------------- |
| Debian  | apt-get update; apt-get install package_name |
| Red Hat | yum install package_name                     |

### 通过软件包文件安装软件

有时候不是从资源库下载了一个软件安装包，这时候就需要使用底层工具来直接安装了。

表格：底层软件包安装命令

| 风格    | 命令                        |
| ------- | --------------------------- |
| Debian  | dpkg --install package_file |
| Red Hat | rpm -i package_file         |

### 卸载软件

表格: 软件包删除命令

| 风格    | 命令                        |
| ------- | --------------------------- |
| Debian  | apt-get remove package_name |
| Red Hat | yum erase package_name      |

### 通过资源库更新软件

表格：软件包更新命令

| 风格    | 命令                            |
| ------- | ------------------------------- |
| Debian  | apt-get update; apt-get upgrade |
| Red Hat | yum update                      |

## 存储媒介

### 挂载和卸载存储设备

管理存储设备的第一步是把设备连接到文件系统树中。这个叫做”挂载”的过程允许设备连接到操作系统中。 有一个叫做 `/etc/fstab` 的文件可以列出系统启动时要挂载的设备（典型地，硬盘分区）。下面是 来自于 `Fedora 7` 系统的 `/etc/fstab` 文件实例：

```
LABEL=/12               /               ext3        defaults        1   1
LABEL=/home             /home           ext3        defaults        1   2
LABEL=/boot             /boot           ext3        defaults        1   2
tmpfs                   /dev/shm        tmpfs       defaults        0   0
devpts                  /dev/pts        devpts      gid=5,mode=620  0   0
sysfs                   /sys            sysfs       defaults        0   0
proc                    /proc           proc        defaults        0   0
LABEL=SWAP-sda3         /swap           swap        defaults        0   0
```

表格: `/etc/fstab` 字段

| 字段 | 内容         | 说明                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ---- | ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | 设备名       | 传统上，这个字段包含与物理设备相关联的设备文件的实际名字，比如说 `/dev/hda1`（第一个 `IDE` 通道上第一个主设备分区）。然而今天的计算机，有很多热插拔设备（像 `USB` 驱动设备），许多现代的 `Linux` 发行版用一个文本标签和设备相关联。当这个设备连接到系统中时，这个标签（当储存媒介格式化时，这个标签会被添加到存储媒介中）会被操作系统读取。那样的话，不管赋给实际物理设备哪个设备文件，这个设备仍然能被系统正确地识别。 |
| 2    | 挂载点       | 设备所连接到的文件系统树的目录。                                                                                                                                                                                                                                                                                                                                                                                        |
| 3    | 文件系统类型 | `Linux` 允许挂载许多文件系统类型。大多数本地的 `Linux` 文件系统是 `ext3`，但是也支持很多其它的，比方说 `FAT16 (msdos)`, `FAT32 (vfat)`，`NTFS (ntfs)`，`CD-ROM (iso9660)`，等等。                                                                                                                                                                                                                                       |
| 4    | 选项         | 文件系统可以通过各种各样的选项来挂载。有可能，例如，挂载只读的文件系统，或者挂载阻止执行任何程序的文件系统（一个有用的安全特性，避免删除媒介。）                                                                                                                                                                                                                                                                        |
| 5    | 频率         | 一位数字，指定是否和在什么时间用 `dump` 命令来备份一个文件系统。                                                                                                                                                                                                                                                                                                                                                        |
| 6    | 次序         | 一位数字，指定 `fsck` 命令按照什么次序来检查文件系统。                                                                                                                                                                                                                                                                                                                                                                  |

### 查看挂载的文件系统列表

使用不带参数的 `mount` 命令，会显示当前挂载的文件系统。

```bash
[me@linuxbox ~]$ mount
/dev/sda2 on / type ext3 (rw)
```

这个列表的格式是：设备 `on` 挂载点 `type` 文件系统类型（选项）。例如，第一行所示设备 `/dev/sda2` 作为根文件系统被挂载，文件系统类型是 `ext3`，并且可读可写（这个“rw”选项）。

卸载只需要 `unmount /dev/sda2` 就可以了。

### 创建新的文件系统

- 用 `fdisk` 命令操作分区
  使用这个 `fdisk` 可以在设备上编辑，删除，和创建分区。(注意要先卸载)
- 用 `mkfs` 命令创建一个新的文件系统
  它能创建各种格式的文件系统。 在此设备上创建一个 `ext3` 文件系统，我们使用”-t” 选项来指定这个”ext3”系统类型，随后是我们要格式化的设备分区名称。

## 网络系统

### 检查和监测网络

1. `ping`
   检测网络各个部件是否正常工作，**大多数网络设备（包括 `Linux` 主机）都可以被配置为忽略这些数据包来避免受到 `IMCP` 攻击**。
2. `traceroute`
   这个 `traceroute` 程序（一些系统使用相似的 `tracepath` 程序来代替）会显示从本地到指定主机要经过的所有“跳数”的网络流量列表。
3. `netstat`
   `netstat` 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们可以看看网络设置中的各种特性。使用方法可以 `netstat --help` 或者 `man netstat` 查看。

### 网络中传输文件

1. `ftp`
   `FTP`（它的原始形式）并不是安全的，因为它会以明码形式发送帐号的姓名和密码。这就意味着这些数据没有加密，任何嗅探网络的人都能看到。由于此种原因，几乎因特网中所有 `FTP` 服务器 都是匿名的。一个匿名服务器能允许任何人使用注册名“anonymous”和无意义的密码登录系统。
   在 “ftp>” 提示符下，输入 “help”，会显示所支持命令的列表。
2. `wget`
   若想从网络和 `FTP` 网站两者上都能下载数据，`wget` 是很有用处的。不只能下载单个文件，多个文件，甚至整个网站都能下载。

### 与远程主机安全通信

1. `ssh`
   `SSH`（Secure Shell）。首先，它要认证远端主机是否为它所知道的那台主机（这样就阻止了所谓的“中间人”的攻击），其次，它加密了本地与远程主机之间所有的通讯信息。通过远程与本地建立的一个 `VPN` 可以实现：在运行着 X 服务端的系统（也就是，能显示 `GUI` 的机器）上，能登录远端系统并运行一个 X 客户端程序（一个图形化应用），而应用程序的显示结果出现在本地。
2. `scp` 和 `sftp`
   它们可以利用 `SSH` 加密通道在网络间复制文件。第一个，`scp`（安全复制）被用来复制文件，与熟悉的 `cp` 程序非常相似。最显著的区别就是源或者目标路径名要以远端主机的名字，后跟一个冒号字符开头。例如：`scp remote-sys:document.txt .`。第二个 `SSH` 文件复制程序是 `sftp`，顾名思义，它是 `ftp` 程序的安全替代品。`sftp` 工作起来与我们之前使用的 `ftp` 程序很相似；然而，它不用明码形式来传递数据，它使用加密的 `SSH` 通道。`sftp` 有一个重要特性强于传统的 `ftp` 命令，就是 `sftp` 不需要远端系统中运行 `FTP` 服务端。它仅仅需要 `SSH` 服务端。**这意味着任何一台能用 `SSH` 客户端连接的远端机器，也可当作类似于 `FTP` 的服务器来使用。**

## 查找文件

### find

能基于各种各样的属性搜索一个给定目录（以及它的子目录），来查找文件。

最简单的就是接收一个或多个目录名来执行搜索搜索，可以递归输出目录的结构。

`-type` 指定搜索的类型，有以下几种：`b` 块特殊设备文件，`c` 字符特殊设备文件，`d` 目录，`f` 普通文件，`l` 符号链接。其他测试条件：

| 测试条件       | 描述                                                                                                                                                                                        |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -cmin n        | 匹配内容或属性最后修改时间正好在 n 分钟之前的文件或目录。 指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。                                                                      |
| -cnewer file   | 匹配内容或属性最后修改时间晚于 file 的文件或目录。                                                                                                                                          |
| -ctime n       | 匹配内容和属性最后修改时间在 n\*24 小时之前的文件和目录                                                                                                                                     |
| -empty         | 匹配空文件和目录。                                                                                                                                                                          |
| -group name    | 匹配属于一个组的文件或目录。组可以用组名或组 ID 来表示。                                                                                                                                    |
| -iname pattern | 就像-name 测试条件，但是不区分大小写。                                                                                                                                                      |
| -inum n        | 匹配 inode 号是 n 的文件。这对于找到某个特殊 inode 的所有硬链接很有帮助。                                                                                                                   |
| -mmin n        | 匹配内容被修改于 n 分钟之前的文件或目录。                                                                                                                                                   |
| -mtime n       | 匹配的文件或目录的内容被修改于 n\*24 小时之前。                                                                                                                                             |
| -name pattern  | 用指定的通配符模式匹配的文件和目录。                                                                                                                                                        |
| -newer file    | 匹配内容晚于指定的文件的文件和目录。这在编写执行备份的 `shell` 脚本的时候很有帮。每次你制作一个备份，更新文件（比如说日志），然后使用 `find` 命令来判断哪些文件自从上一次更新之后被更改了。 |
| -nouser        | 匹配不属于一个有效用户的文件和目录。这可以用来查找 属于被删除的帐户的文件或监测攻击行为。                                                                                                   |
| -nogroup       | 匹配不属于一个有效的组的文件和目录。                                                                                                                                                        |
| -perm mode     | 匹配权限已经设置为指定的 mode 的文件或目录。mode 可以用 八进制或符号表示法。                                                                                                                |
| -samefile name | 类似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。                                                                                                                             |
| -size n        | 匹配大小为 n 的文件                                                                                                                                                                         |
| -type c        | 匹配文件类型是 c 的文件。                                                                                                                                                                   |
| -user name     | 匹配属于某个用户的文件或目录。这个用户可以通过用户名或用户 ID 来表示。                                                                                                                      |

即使拥有了 `find` 命令提供的所有测试条件，我们还需要一个更好的方式来描述测试条件之间的逻辑关系。`find` 命令提供了 一种方法来结合测试条件，通过使用逻辑操作符来创建更复杂的逻辑关系。例如：`find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)` 表示查找当前用户目录下权限不是 `0600` 的文件和全新啊不是 `0700` 的文件夹。更多操作符：

| 操作符 | 描述                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -and   | 如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。 注意若没有使用操作符，则默认使用 -and。                                                                                                                                                                                                                                                                                                                            |
| -or    | 若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。                                                                                                                                                                                                                                                                                                                                                                  |
| -not   | 若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号（!）。                                                                                                                                                                                                                                                                                                                                                            |
| ()     | 把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。 默认情况下，`find` 命令按照从左到右的顺序计算。经常有必要重写默认的求值顺序，以得到期望的结果。 即使没有必要，有时候包括组合起来的字符，对提高命令的可读性是很有帮助的。注意 因为圆括号字符对于 `shell` 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 `find` 命令。通常反斜杠字符被用来转义圆括号字符。 |

`find` 命令允许基于搜索结果来执行操作。有许多预定义的操作和几种方式来应用用户定义的操作。

| 操作    | 描述                                                                      |
| ------- | ------------------------------------------------------------------------- |
| -delete | 删除当前匹配的文件。                                                      |
| -ls     | 对匹配的文件执行等同的 `ls -dils` 命令。并将结果发送到标准输出。          |
| -print  | 把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。 |
| -quit   | 一旦找到一个匹配，退出。                                                  |

例如：`find ~ -type f -name '*.BAK' -delete` 代表在用户目录下递归找到文件名以 `.BAK` 结尾的文件，并删除。

当然除了上面 4 个操作外，还可以执行任何用户自定义的命令，只要使用 `-exec` 来连接就好了，`-ok` 和 `-exec` 类似，只不过多了提升用户的信息：

`find ~ -type f -name 'foo*' -ok ls -l '{}' ';'` 代表在用户目录下查找名字以 `foo` 开头的文件，并提示用户是否对匹配的文件执行 `ls -l` 命令。

> 当 `-exec` 行为被使用的时候，若每次找到一个匹配的文件，它会启动一个新的指定命令的实例。我们可能更愿意把所有的搜索结果结合起来，再运行一个命令的实例。例如，与其像这样执行命令：

```bash
ls -l file1
ls -l file2
```

> 我们更喜欢：

```bash
ls -l file1 file2
```

> 通过把末尾的分号改为加号，就激活了 `find` 命令的一个功能，把搜索结果结合为一个参数列表，然后用于所期望的命令的一次执行。
> `find ~ -type f -name 'foo*' -exec ls -l '{}' +` 这样系统只用执行一次 `ls` 命令。

## 归档和备份

### 压缩文件

压缩算法（数学技巧被用来执行压缩任务）分为两大类，无损压缩和有损压缩。无损压缩保留了原始文件的所有数据。有损压缩的例子有 `JPEG`（图像）文件和 `MP3`（音频）文件。

#### gzip(无损)

这个 `gzip` 程序被用来压缩一个或多个文件。当执行 `gzip` 命令时，则原始文件的压缩版会替代原始文件。相对应的 `gunzip` 程序被用来把压缩文件复原为没有被压缩的版本。

`gzip` 命令有许多选项：

| 选项    | 说明                                                                                                                                                     |
| ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -c      | 把输出写入到标准输出，并且保留原始文件。也有可能用--stdout 和--to-stdout 选项来指定。                                                                    |
| -d      | 解压缩。正如 gunzip 命令一样。也可以用--decompress 或者--uncompress 选项来指定.                                                                          |
| -f      | 强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用--force 选项来指定。                                                                       |
| -h      | 显示用法信息。也可用--help 选项来指定。                                                                                                                  |
| -l      | 列出每个被压缩文件的压缩数据。也可用--list 选项。                                                                                                        |
| -r      | 若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用--recursive 选项来指定。                                                                   |
| -t      | 测试压缩文件的完整性。也可用--test 选项来指定。                                                                                                          |
| -v      | 显示压缩过程中的信息。也可用--verbose 选项来指定。                                                                                                       |
| -number | 设置压缩指数。number 是一个在 1（最快，最小压缩）到 9（最慢，最大压缩）之间的整数。 数值 1 和 9 也可以各自用--fast 和--best 选项来表示。默认值是整数 6。 |

#### bzip2(无损)

与 `gzip` 程序相似，但是使用了不同的压缩算法，舍弃了压缩速度，而实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 `gzip`。由 `bzip2` 压缩的文件，用扩展名 `.bz2` 来表示。`gzip` 程序的所有选项（除了 `-r`），`bzip2` 程序同样也支持。注意，然而，压缩级别选项（`-number`）对于 `bzip2` 程序来说，有少许不同的含义。

> 不要强制压缩。如果你再次压缩已经压缩过的文件，实际上你会得到一个更大的文件。这是因为所有的压缩技术都会涉及一些开销，文件中会被添加描述此次压缩过程的信息。如果你试图压缩一个已经不包含多余信息的文件，那么再次压缩不会节省空间，以抵消额外的花费。

### 归档文件

#### tar

语法：

```bash
tar mode[options] pathname...
```

这里的 `mode` 是指以下操作模式（这里只展示了一部分，查看 `tar` 的手册(`man tar`)来得到完整列表）之一：

| 模式 | 说明                               |
| ---- | ---------------------------------- |
| c    | 为文件和／或目录列表创建归档文件。 |
| x    | 抽取归档文件。                     |
| r    | 追加具体的路径到归档文件的末尾。   |
| t    | 列出归档文件的内容。               |

`tar` 命令另一个有趣的行为是它处理归档文件路径名的方式。默认情况下，路径名是相对的，而不是绝对路径。当以相对路径创建归档文件的时候，`tar` 命令会简单地删除路径名开头的斜杠。这就意味着到时候解压出来是在运行命令的目录下解压出相对目录结构，例如：`tar cf playground.tar playground` 打的压缩包解压出来还是只有 `playground` 的目录，而 `tar cf playground2.tar ~/playground` 打的压缩包解压出来会包含 `/home/user/playground` 的父级目录，故而一般绝对路径可以完整复原压缩前的目录结构（**要求解压命令在根目录执行**）。

当抽取一个归档文件时，有可能限制从归档文件中抽取什么内容。例如，如果我们想要抽取单个文件，可以这样实现：

```bash
tar xf archive.tar pathname
```

`tar` 命令经常结合 `find` 命令一起来制作归档文件。在这个例子里，我们将会使用 `find` 命令来产生一个文件集合，然后这些文件被包含到归档文件中。

```bash
find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'
```

这里我们使用 `find` 命令来匹配 `playground` 目录中所有名为 `file-A` 的文件，然后使用 `-exec` 行为，来唤醒带有追加模式（`r`）的 `tar` 命令，把匹配的文件添加到归档文件 `playground.tar` 里面。

`tar` 还可以和标准输入输出连接，使用“-”来表示 标准输入／输出的惯例，也被大量的其它程序使用。

```bash
find playground -name 'file-A' | tar cf - --files-from=- | gzip > playground.tgz
```

上面的命令以为这从 `playground` 文件夹中找到文件名为 `file-A` 的文件，并将结果输出标准输出，接着 `tar` 命令利用 `--files-from=-` 从标准输入读取要归档的文件进行归档，最后连接到 `gzip` 进行打包，结果输出到文件 `playground.tgz`。

> 虽然我们使用 `gzip` 程序来制作我们的压缩归档文件，但是现在的 `GUN` 版本的 `tar` 命令，`gzip` 和 `bzip2` 压缩两者都直接支持，各自使用 `z` 和 `j` 选项。

#### zip

这个 `zip` 程序既是压缩工具，也是一个打包工具。这程序使用的文件格式，`Windows` 用户比较熟悉，因为它读取和写入 `.zip` 文件。然而，在 `Linux` 中 `gzip` 是主要的压缩程序，而 `bzip2` 则位居第二。

```bash
zip options zipfile file...
```

除非包含 `-r` 选项，要不然只有目录（**没有任何它的内容**）被存储。(`zip -r test.zip home/user/test`)

在创建 `zip` 版本的文件包时，`zip` 命令通常会显示一系列的信息：

```bash
adding: github/test/source/src/node/express.js (deflated 57%)
adding: github/test/source/src/node/mysql.js (deflated 55%)
adding: github/test/source/src/node/callback/ (stored 0%)
```

这些信息显示了添加到文件包中每个文件的状态。`zip` 命令会使用两种存储方法之一，来添加文件到文件包中：要不它会“store”没有压缩的文件，正如这里所示，或者它会“deflate”文件，执行压缩操作。在存储方法之后显示的数值表明了压缩量。

对于 `zip` 命令（与 `tar` 命令相反）要注意一点，就是如果指定了一个已经存在的文件包，其被更新而不是被替代。

像 `tar` 命令一样，`zip` 命令能够利用标准输入和输出，虽然它的实施不大有用。通过 `-@` 选项，有可能把一系列的文件名管道到 `zip` 命令。`find playground -name "file-A" | zip -@ file-A.zip`

### 同步文件和目录

`rsync` 这个程序能同步本地与远端的目录，通过使用 `rsync` 远端更新协议，此协议允许 `rsync` 快速地检测两个目录的差异，执行最小量的复制来达到目录间的同步。比起其它种类的复制程序，这就使 `rsync` 命令非常快速和高效。

```bash
rsync options source destination
```

这里 `source` 和 `destination` 是下列选项之一：

- 一个本地文件或目录
- 一个远端文件或目录，以 `[user@]host:path` 的形式存在
- 一个远端 `rsync` 服务器，由 `rsync://[user@]host[:port]/path` 指定

`rsync` 也可以作为本地一个守护进程启动，然后监听网络上的 `rsync` 请求来同步目录。可以支持 `ssh` 和 `rsycn` 协议。

## 正则表达式

### grep

“grep”这个名字 来自于短语“global regular expression print”，所以 `grep` 程序与正则表达式有着千丝万缕的联系。

```bash
grep [options] regex [file...]
```

表格: grep 选项

| 选项 | 描述                                                                                                                               |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------- |
| -i   | 忽略大小写。不会区分大小写字符。也可用--ignore-case 来指定。                                                                       |
| -v   | 不匹配。通常，grep 程序会打印包含匹配项的文本行。这个选项导致 grep 程序只会打印不包含匹配项的文本行。也可用--invert-match 来指定。 |
| -c   | 打印匹配的数量（或者是不匹配的数目，若指定了-v 选项），而不是文本行本身。 也可用--count 选项来指定。                               |
| -l   | 打印包含匹配项的文件名，而不是文本行本身，也可用--files-with-matches 选项来指定。                                                  |
| -L   | 相似于-l 选项，但是只是打印不包含匹配项的文件名。也可用--files-without-match 来指定。                                              |
| -n   | 在每个匹配行之前打印出其位于文件中的相应行号。也可用--line-number 选项来指定。                                                     |
| -h   | 应用于多文件搜索，不输出文件名。也可用--no-filename 选项来指定。                                                                   |

### 元字符和原义字符(Metacharacters And Literals)

像 `grep -L bzip dirlist*.txt` 中的 `bzip` 每一个字符都是原义字符，因此它们匹配本身。除了原义字符之外，正则表达式也可能包含元字符，其被用来指定更复杂的匹配项。正则表达式元字符由以下字符组成(反斜杠可以将元字符转化为原义字符)：

```
^ $ . [ ] { } - ? * + ( ) | \
```

### POSIX 字符集

表格: POSIX 字符集

| 字符集     | 说明                                                                                               |
| ---------- | -------------------------------------------------------------------------------------------------- |
| [:alnum:]  | 字母数字字符。在 ASCII 中，等价于：[A-Za-z0-9]                                                     |
| [:word:]   | 与[:alnum:]相同, 但增加了下划线字符。                                                              |
| [:alpha:]  | 字母字符。在 ASCII 中，等价于：[A-Za-z]                                                            |
| [:blank:]  | 包含空格和 tab 字符。                                                                              |
| [:cntrl:]  | ASCII 的控制码。包含了 0 到 31，和 127 的 ASCII 字符。                                             |
| [:digit:]  | 数字 0 到 9                                                                                        |
| [:graph:]  | 可视字符。在 ASCII 中，它包含 33 到 126 的字符。                                                   |
| [:lower:]  | 小写字母。                                                                                         |
| [:punct:]  | 标点符号字符。在 ASCII 中，等价于：[-!"#\$%&'()\*+,./:;<=>?@[\\\]_`{|}~]                           |
| [:print:]  | 可打印的字符。在[:graph:]中的所有字符，再加上空格字符。                                            |
| [:space:]  | 空白字符，包括空格、tab、回车、换行、vertical tab 和 form feed.在 ASCII 中， 等价于：[ \t\r\n\v\f] |
| [:upper:]  | 大写字母。                                                                                         |
| [:xdigit:] | 用来表示十六进制数字的字符。在 ASCII 中，等价于：[0-9A-Fa-f]                                       |

`POSIX` 把正则表达式的实现分成了两类：基本正则表达式（BRE）和扩展的正则表达式（ERE）。

`BRE` 可以辨别以下元字符：

```
^ $ . [ ] *
```

`ERE` 添加了以下元字符（以及与其相关的功能）:

```
( ) { } ? + |
```

我们熟知的 `grep` 就同时支持这两种，通过 `-E` 来启用 `ERE`:

```zsh
# 基本正则表达式，| 被看做字符
[me@linuxbox ~]$ echo "BBB" | grep 'AAA|BBB'

[me@linuxbox ~]$ echo "BBB" | grep -E 'AAA|BBB'
BBB
```

### 其他

其他正则表达式可查看 [表达式全集](http://tool.oschina.net/uploads/apidocs/jquery/regexp.html)

## 文本处理

### cat

`cat` 程序具有许多有趣的选项。其中许多选项用来帮助更好的可视化文本内容。一个例子是 `-A` 选项，其用来在文本中显示非打印字符(比如 `tab` 字符和回车字符)。

`cat` 程序也包含用来修改文本的选项。最著名的两个选项是 `-n`，其给文本行添加行号和 `-s`，禁止输出多个空白行。

### sort

`sort` 程序可以对对标准输入的内容，或命令行中指定的一个或多个文件进行排序，然后把排序结果发送到标准输出。

表格: 常见的 `sort` 程序选项

| 选项 | 长选项                  | 描述                                                                                                                                                                                                                               |
| ---- | ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -b   | --ignore-leading-blanks | 默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 `sort` 程序忽略 每行开头的空格，从第一个非空白字符开始排序。                                                                                                      |
| -f   | --ignore-case           | 让排序不区分大小写。                                                                                                                                                                                                               |
| -n   | --numeric-sort          | 基于字符串的数值来排序。使用此选项允许根据数字值执行排序，而不是字母值。**如果一个字段由数字和字母组成，那么只会对前面的数字排序，忽略后续的所有字符，当数字部分相同时才将后面剩余的字符串按字母顺序排列**，如 `1n3` 会忽略 `n3`。 |
| -r   | --reverse               | 按相反顺序排序。结果按照降序排列，而不是升序。                                                                                                                                                                                     |
| -k   | --key=field1[,field2]   | 对从 field1 到 field2 之间的字符排序，而不是整个文本行。看下面的讨论。                                                                                                                                                             |
| -m   | --merge                 | 把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。                                                                                                                                     |
| -o   | --output=file           | 把排好序的输出结果发送到文件，而不是标准输出。                                                                                                                                                                                     |
| -t   | --field-separator=char  | 定义域分隔字符。默认情况下，域由空格或制表符分隔。                                                                                                                                                                                 |

如果要对日期排序，在计算机中，日期通常设置为 `YYYY-MM-DD` 格式，这样使按时间顺序排序变得容易，但是如果日期为美国格式 `MM/DD/YYYY`，排序就更加困难了。幸运地是，`sort` 程序提供了一种方式。这个 `key` 选项允许在字段中指定偏移量，所以我们能在字段中定义键值。

```bash
[me@linuxbox ~]$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt
Fedora         10    11/25/2008
Ubuntu         8.10  10/30/2008
SUSE           11.0  06/19/2008
...
```

通过指定 -k 3.7，我们指示 sort 程序使用一个排序键值，其始于第三个字段中的第七个字符，对应于 年的开头。同样地，我们指定 -k 3.1 和 -k 3.4 来分离日期中的月和日。 我们也添加了 n 和 r 选项来实现一个逆向的数值排序。这个 b 选项用来删除日期字段中开头的空格（ 行与行之间的空格数迥异，因此会影响 sort 程序的输出结果）。

### uniq(默认删除相邻的重复行)

与 `sort` 程序相比，这个 `uniq` 程序是个轻量级程序。`uniq` 执行一个看似琐碎的行为。当给定一个排好序的文件（包括标准输出），`uniq` 会删除任意重复行，并且把结果发送到标准输出。它常常和 `sort` 程序一块使用，来清理重复的输出。

表格: 常用的 `uniq` 选项

| 选项 | 说明                                                                                                                                             |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| -c   | 输出所有的重复行，并且每行开头显示重复的次数。                                                                                                   |
| -d   | 只输出重复行，而不是特有的文本行。                                                                                                               |
| -f   | n 忽略每行开头的 n 个字段，字段之间由空格分隔，正如 `sort` 程序中的空格分隔符；然而，不同于 `sort` 程序，`uniq` 没有选项来设置备用的字段分隔符。 |
| -i   | 在比较文本行的时候忽略大小写。                                                                                                                   |
| -s   | n 跳过（忽略）每行开头的 n 个字符。                                                                                                              |
| -u   | 只输出独有的文本行。这是默认的。                                                                                                                 |

### cut

表格: `cut` 程序选择项

| 选项          | 说明                                                                                                                     |
| ------------- | ------------------------------------------------------------------------------------------------------------------------ |
| -c char_list  | 从文本行中抽取由 char_list 定义的文本。这个列表可能由一个或多个逗号分隔开的数值区间组成(`1,3` 或 `1-3,5-6` 都是合法的)。 |
| -f field_list | 从文本行中抽取一个或多个由 field_list 定义的字段。这个列表可能 包括一个或多个字段，或由逗号分隔开的字段区间。            |
| -d delim_char | 当指定-f 选项之后，使用 delim_char 做为字段分隔符。默认情况下， 字段之间必须由单个 tab 字符分隔开。                      |
| --complement  | 抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。                                                                   |

### paste

这个 `paste` 命令的功能正好与 `cut` 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。类似于 `cut` 命令，`paste` 接受多个文件参数和 `／` 或标准输入。例如将 `A` 文件的每一行的 3 个字段(`A1 A2 A3`)与 `B` 文件的每一行 2 个字段(`B1 B2`)合并并输出到标准输出流(`A1 A2 A3 B1 B2`)，命令为 `paste A B`。

### join

类似关系型数据库的 `join` 操作，找到两个或多个文件中相同的字段，然后进行合并。

### common

这个 `comm` 程序会比较两个文本文件，并且会显示每个文件特有的文本行和共有的文本行。

`comm` 命令产生了三列输出。第一列包含第一个文件独有的文本行；第二列，文本行是第二列独有的；第三列包含两个文件共有的文本行。`comm` 支持 `-n` 形式的选项，这里 `n` 代表 1，2 或 3。这些选项使用的时候，指定了要**隐藏**的列。

### diff

类似于 `comm` 程序，`diff` 程序被用来监测文件之间的差异。然而，`diff` 是一款更加复杂的工具，它支持许多输出格式，并且一次能处理许多文本文件。软件开发员经常使用 `diff` 程序来检查不同程序源码版本之间的更改，`diff` 能够递归地检查源码目录，经常称之为源码树。

和 `git diff` 有点类似。

表格: `diff` 更改命令

| 改变  | 说明                                                                             |
| ----- | -------------------------------------------------------------------------------- |
| r1ar2 | 把第二个文件中位置 r2 处的文件行添加到第一个文件中的 r1 处。                     |
| r1cr2 | 用第二个文件中位置 r2 处的文本行更改（替代）位置 r1 处的文本行。                 |
| r1dr2 | 删除第一个文件中位置 r1 处的文本行，这些文本行将会出现在第二个文件中位置 r2 处。 |

表格：`diff -c`

| 指示符 | 意思                                                                     |
| ------ | ------------------------------------------------------------------------ |
| blank  | 上下文显示行。它并不表示两个文件之间的差异。                             |
| -      | 删除行。这一行将会出现在第一个文件中，而不是第二个文件内。               |
| +      | 添加行。这一行将会出现在第二个文件内，而不是第一个文件中。               |
| !      | 更改行。将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分。 |

表格：`diff -u`

| 字符 | 意思                       |
| ---- | -------------------------- |
| 空格 | 两个文件都包含这一行。     |
| -    | 在第一个文件中删除这一行。 |
| +    | 添加这一行到第一个文件中。 |

### patch

这个 `patch` 程序被用来把更改应用到文本文件中。它接受从 `diff` 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本。

```bash
diff -Naur old_file new_file > diff_file
patch < diff_file
```

### tr

这个 `tr` 程序被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。如 `echo "lowercase letters" | tr a-z A-Z` 输出 `LOWERCASE LETTERS`。

### sed

名字 `sed` 是 `stream editor`（流编辑器）的简称。它对文本流，即一系列指定的文件或标准输入进行编辑。`sed` 是一款强大的，并且有些复杂的程序（有整本内容都是关于 `sed` 程序的书籍），这里只简单介绍。

表格: `sed` 地址表示法

| 地址        | 说明                                                                                                                                                                                 |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| n           | 行号，n 是一个正整数。                                                                                                                                                               |
| \$          | 最后一行。                                                                                                                                                                           |
| /regexp/    | 所有匹配一个 POSIX 基本正则表达式的文本行。注意正则表达式通过 斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc 来 指定表达式，这里 c 就是一个备用的字符。 |
| addr1,addr2 | 从 addr1 到 addr2 范围内的文本行，包含地址 addr2 在内。地址可能是上述任意 单独的地址形式。                                                                                           |
| first~step  | 匹配由数字 first 代表的文本行，然后随后的每个在 step 间隔处的文本行。例如 1~2 是指每个位于偶数行号的文本行，5~5 则指第五行和之后每五行位置的文本行。                                 |
| addr1,+n    | 匹配地址 addr1 和随后的 n 个文本行。                                                                                                                                                 |
| addr!       | 匹配所有的文本行，除了 addr 之外，addr 可能是上述任意的地址形式。                                                                                                                    |

表格: `sed` 基本编辑命令

| 命令                  | 说明                                                                                                                                                                                                                                                                                                                                  |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| =                     | 输出当前的行号。                                                                                                                                                                                                                                                                                                                      |
| a                     | 在当前行之后追加文本。                                                                                                                                                                                                                                                                                                                |
| d                     | 删除当前行。                                                                                                                                                                                                                                                                                                                          |
| i                     | 在当前行之前插入文本。                                                                                                                                                                                                                                                                                                                |
| p                     | 打印当前行。默认情况下，sed 程序打印每一行，并且只是编辑文件中匹配 指定地址的文本行。通过指定-n 选项，这个默认的行为能够被忽略。                                                                                                                                                                                                      |
| q                     | 退出 sed，不再处理更多的文本行。如果不指定-n 选项，输出当前行。                                                                                                                                                                                                                                                                       |
| Q                     | 退出 sed，不再处理更多的文本行。                                                                                                                                                                                                                                                                                                      |
| s/regexp/replacement/ | 只要找到一个 regexp 匹配项，就替换为 replacement 的内容。 replacement 可能包括特殊字符 &，其等价于由 regexp 匹配的文本。另外， replacement 可能包含序列 \1 到 \9，其是 regexp 中相对应的子表达式的内容。更多信息，查看 下面 back references 部分的讨论。在 replacement 末尾的斜杠之后，可以指定一个 可选的标志，来修改 s 命令的行为。 |
| y/                    | set1/set2 执行字符转写操作，通过把 set1 中的字符转变为相对应的 set2 中的字符。 注意不同于 tr 程序，sed 要求两个字符集合具有相同的长度。                                                                                                                                                                                               |

## 格式化输出

### nl-添加行号

表格: 常用 `nl` 选项

| 选项      | 含义                                                                                                                              |
| --------- | --------------------------------------------------------------------------------------------------------------------------------- |
| -b style  | 把 body 按被要求方式数行，可以是以下方式： a = 数所有行; t = 数非空行。这是默认设置;n = 无;pregexp = 只数那些匹配了正则表达式的行 |  |
| -f style  | 将 footer 按被要求设置数。默认是无                                                                                                |
| -h style  | 将 header 按被要求设置数。默认是                                                                                                  |
| -i number | 将页面增加量设置为数字。默认是一。                                                                                                |
| -n format | 设置数数的格式，格式可以是：ln = 左偏，没有前导零;rn = 右偏，没有前导零;rz = 右偏，有前导零。                                     |
| -p        | 不要在没一个逻辑页面的开始重设页面数。                                                                                            |
| -s string | 在没一个行的末尾加字符作分割符号。默认是单个的 tab。                                                                              |
| -v number | 将每一个逻辑页面的第一行设置成数字。默认是一。                                                                                    |
| -w width  | 将行数的宽度设置，默认是六。                                                                                                      |

### fold - 限制文件行宽

```bash
[me@linuxbox ~]$ echo "The quick brown fox jumped over the lazy dog." | fold -w 12 -s
The quick
brown fox
jumped over
the lazy
dog.
```

### fmt - 一个简单的文本格式器

`fmt` 程序同样折叠文本，外加很多功能。它接受文本或标准输入并且在文本流上呈现照片转换。它主要是填充和连接文本行，同时保留空白符和缩进。

### printf

表格: `printf` 转换规范组件

| 组件 | 描述                                         |
| ---- | -------------------------------------------- |
| d    | 将数字格式化为带符号的十进制整数             |
| f    | 格式化并输出浮点数                           |
| o    | 将整数格式化为八进制数                       |
| s    | 将字符串格式化                               |
| x    | 将整数格式化为十六进制数，必要时使用小写 a-f |
| X    | 与 x 相同，但变为大写                        |
| %    | 打印 % 符号 (比如，指定 “%%”)                |

`printf` 转换规范组件:

1. `flags`
   有 5 种不同的标志:
   `#`: 使用“备用格式”输出。这取决于数据类型。对于 o（八进制数）转换，输出以 0 为前缀.对于 x 和 X（十六进制数）转换，输出分别以 0x 或 0X 为前缀。0–(零) 用零填充输出。这意味着该字段将填充前导零，比如“000380”。
   `-`: (破折号) 左对齐输出。默认情况下，`printf` 右对齐输出。
   `' '`: (空格) 在正数前空一格。
   `+`: (加号) 在正数前添加加号。默认情况下，`printf` 只在负数前添加符号。
2. `width` 指定最小字段宽度的数。
3. `.precision` 对于浮点数，指定小数点后的精度位数。对于字符串转换，指定要输出的字符数。

## 打印和编译请查看源书
