---
title: 前端基础之JS内存管理
date: 2018-09-13 17:31:54
tags:
  - 前端
  - JS
  - 内存管理
---

## 内存生命周期

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放\归还

<!-- more -->

### JavaScript 的内存分配

- 值的初始化

```js
var n = 123 // 给数值变量分配内存
var s = 'azerty' // 给字符串分配内存

var o = {
  a: 1,
  b: null
} // 给对象及其包含的值分配内存
```

- 函数调用分配内存

```js
var d = new Date() // 分配一个 Date 对象
```

### 当内存不再需要使用时释放

高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。

## 垃圾回收

### 引用计数垃圾收集

老的浏览器使用这种方式，比如 `IE 6`，`IE 7`。

```js
var o = {
  a: {
    b: 2
  }
}
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集

var o2 = o // o2变量是第二个对“这个对象”的引用

o = 1 // 现在，“这个对象”的原始引用o被o2替换了

var oa = o2.a
// 引用“这个对象”的a属性
// 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = 'yo'
// 最初的对象现在已经是零引用了
// 他可以被垃圾回收了
// 然而它的属性a的对象还在被oa引用，所以还不能回收

oa = null
// a属性的那个对象现在也是零引用了
// 它可以被垃圾回收了
```

> 限制，当有**循环引用**时，则无法进行垃圾回收。
    ```js
    function f() {
      var o = {}
      var o2 = {}
      o.a = o2 // o 引用 o2
      o2.a = o // o2 引用 o

      return 'azerty'
    }

    f()
    ```

### 标记-清除算法

这个算法假定设置一个叫做根（`root`）的对象（在 `Javascript` 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。

从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 `JavaScript` 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。
